<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMP Document Converter</title>
    <link rel="stylesheet" href="css/cmp-doc-converter.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="js/cmp-doc-converter-config.js"></script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üîß CMP Document Converter</h1>
            <p>Transform your Word documents into Brightspace-ready HTML Files</p>
        </div>

        <div class="main-content">
            <div class="alert alert-info">
                <h3>üìã About This Tool</h3>
                <p>This tool converts CMP-ready Word documents into individual HTML files. Each H1 section becomes a
                    separate file optimized for Brightspace upload.</p>
                <p><strong>Important:</strong> Review all generated files and insert all media/interactives before
                    uploading to Brightspace.</p>
                <p>Refer to the <a href="docs/cmp-document-converter-instructions.html" target="_new"><strong>complete
                            instructions guide</strong></a> for detailed information on using this tool. </p>
            </div>

            <div class="step-card step-1">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3 class="step-title">Convert Word to HTML</h3>
                </div>
                <p><strong>Use Pandoc (recommended) or a similar converter to generate HTML from your LO Word
                        document.</strong></p>
                <p>Recommended pandoc command:</p>
                <div class="code-block">
                    <code>pandoc input.docx -s -o output.html --extract-media=. --ascii</code>
                </div>
                <p><em>This extracts media files and ensures ASCII compatibility for web use.</em></p>
            </div>

            <div class="step-card step-2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3 class="step-title">Test Connection</h3>
                </div>
                <div class="input-group">
                    <p>You can skip this step as it is for debugging only. Do not change the webhook URL unless
                        instructed to do so.</p>
                    <label for="webhookUrl">Webhook URL:</label>
                    <input type="url" id="webhookUrl"
                        value="https://learningtechnologies.app.n8n.cloud/webhook/cmp-document-upload">
                </div>
                <button class="btn btn-info" onclick="testWebhook()">üß™ Test Connection</button>
                <div id="testResult"></div>
            </div>

            <div class="step-card step-3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3 class="step-title">Upload & Convert</h3>
                </div>
                <div class="alert alert-warning" style="margin-bottom: 1rem;">
                    <strong>‚ö†Ô∏è Important:</strong> Only HTML files (.html, .htm) are accepted. Other file types will be
                    rejected automatically.
                </div>
                <div class="input-group">
                    <label for="document">Upload your HTML document using one of the methods below:</label>
                    <p style="margin: 0.5rem 0; color: #666; font-size: 0.9rem;">
                        <strong>Method 1:</strong> Drag and drop your HTML file into the area below<br>
                        <strong>Method 2:</strong> Click "Browse HTML Files" to select from your computer
                    </p>

                    <!-- Custom Drag & Drop File Area -->
                    <div class="file-drop-zone" id="fileDropZone" ondrop="handleDrop(event)"
                        ondragover="allowDrop(event)" ondragleave="handleDragLeave(event)">
                        <div class="drop-zone-content">
                            <div class="drop-zone-icon">üìÅ</div>
                            <div class="drop-zone-text">
                                <p><strong>Drag & Drop one HTML file here</strong></p>
                                <p class="drop-zone-or">or</p>
                                <button type="button" class="btn btn-secondary" onclick="triggerFileSelect()">
                                    üìÇ Browse HTML Files
                                </button>
                            </div>
                            <div class="drop-zone-hint">
                                <small>Only HTML files (.html, .htm) are accepted</small>
                            </div>
                        </div>
                    </div>

                    <!-- Hidden file input -->
                    <input type="file" id="document" accept=".html,.htm" style="display: none;"
                        title="Only HTML files (.html, .htm) are accepted">

                    <!-- Selected file display -->
                    <div id="selectedFileDisplay"
                        style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e8; border-radius: 5px; border: 1px solid #c3e6cb;">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <strong>üìÑ Selected file:</strong> <span id="selectedFileName"></span>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearSelectedFile()">
                                ‚ùå Clear
                            </button>
                        </div>
                    </div>
                </div>
                <button class="btn btn-primary" id="convertButton" onclick="convertDocument()" style="min-width: 280px; white-space: nowrap;">
                    <span id="buttonText">üöÄ Convert Document</span>
                    <div id="progressBar" style="display: none; width: 100%; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; margin-top: 8px; overflow: hidden;">
                        <div id="progressFill" style="height: 100%; background: rgba(255,255,255,0.8); width: 0%; transition: width 0.3s ease; border-radius: 2px;"></div>
                    </div>
                </button>
            </div>

            <div class="section">
                <button class="collapsible">üìã Debug Log</button>
                <div class="content">
                    <div id="debugLog" class="log">Ready to process your document...\n</div>
                    <button class="btn btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
                </div>
            </div>

            <div id="debugInfo" style="display: none;">
                <button class="collapsible">üîç Debug Information</button>
                <div class="content">
                    <div id="debugDetails" class="log"></div>
                </div>
            </div>

            <div id="results" style="display: none;">
                <div class="section">
                    <h3 style="color: var(--primary-color); margin-bottom: 1rem;">üìÅ Processing Results</h3>
                    <div id="fileList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store the latest result for ZIP download
        let latestResult = null;

        function log(message) {
            const debugLog = document.getElementById('debugLog');
            const timestamp = UTILS.formatTimestamp();
            debugLog.textContent += `[${timestamp}] ${message}\n`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function clearLog() {
            document.getElementById('debugLog').textContent = MESSAGES.LOG_CLEARED;
        }

        async function testWebhook() {
            const webhookUrl = document.getElementById('webhookUrl').value;
            const testResult = document.getElementById('testResult');

            if (!webhookUrl) {
                testResult.innerHTML = TEMPLATES.missingWebhookResponse();
                return;
            }

            log(`Testing webhook: ${webhookUrl}`);

            try {
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ test: true })
                });

                log(`Response status: ${response.status}`);
                log(`Response headers: ${JSON.stringify([...response.headers.entries()])}`);

                if (response.ok) {
                    testResult.innerHTML = TEMPLATES.successResponse();
                    log(MESSAGES.WEBHOOK_TEST_SUCCESS);
                } else {
                    const errorText = await response.text();
                    testResult.innerHTML = TEMPLATES.warningResponse(response.status);
                    log(`Response body: ${errorText}`);
                }

            } catch (error) {
                testResult.innerHTML = TEMPLATES.errorResponse(error.message);
                log(`${MESSAGES.WEBHOOK_TEST_FAILED}: ${error.message}`);

                if (error.message.includes('fetch')) {
                    log(MESSAGES.NETWORK_ERROR);
                    MESSAGES.CORS_SOLUTIONS.forEach(solution => log(solution));
                }
            }
        }

        // Validate file type when file is selected
        function validateFileType() {
            const fileInput = document.getElementById('document');
            const file = fileInput.files[0];

            if (file) {
                const fileName = file.name.toLowerCase();
                const allowedExtensions = ['.html', '.htm'];
                const isValidFile = allowedExtensions.some(ext => fileName.endsWith(ext));

                if (!isValidFile) {
                    log(`‚ùå Invalid file type: ${file.name}`);
                    log(`‚ö†Ô∏è Only HTML files (.html, .htm) are allowed`);
                    log(`üí° Please select an HTML file converted from your Word document`);

                    // Clear the file input
                    fileInput.value = '';

                    // Hide selected file display
                    hideSelectedFile();

                    // Show error message
                    alert(`Invalid file type!\n\nOnly HTML files (.html, .htm) are accepted.\n\nSelected file: ${file.name}\n\nPlease select an HTML file converted from your Word document.`);
                    return false;
                } else {
                    log(`‚úÖ Valid HTML file selected: ${file.name}`);
                    showSelectedFile(file);
                    return true;
                }
            }
            return true;
        }

        // Drag & Drop Functions
        function allowDrop(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];

                // Check file type
                const fileName = file.name.toLowerCase();
                const allowedExtensions = ['.html', '.htm'];
                const isValidFile = allowedExtensions.some(ext => fileName.endsWith(ext));

                if (!isValidFile) {
                    log(`‚ùå Invalid file type dropped: ${file.name}`);
                    log(`‚ö†Ô∏è Only HTML files (.html, .htm) are allowed`);
                    alert(`Invalid file type!\n\nOnly HTML files (.html, .htm) are accepted.\n\nDropped file: ${file.name}\n\nPlease drag an HTML file converted from your Word document.`);
                    return;
                }

                // Set file to hidden input
                const fileInput = document.getElementById('document');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;

                log(`‚úÖ Valid HTML file dropped: ${file.name}`);
                showSelectedFile(file);
            }
        }

        function triggerFileSelect() {
            document.getElementById('document').click();
        }

        function showSelectedFile(file) {
            const display = document.getElementById('selectedFileDisplay');
            const fileName = document.getElementById('selectedFileName');

            fileName.textContent = file.name;
            display.style.display = 'block';
        }

        function hideSelectedFile() {
            const display = document.getElementById('selectedFileDisplay');
            display.style.display = 'none';
        }

        function clearSelectedFile() {
            const fileInput = document.getElementById('document');
            fileInput.value = '';
            hideSelectedFile();
            log('üóëÔ∏è File selection cleared');
        }

        // Helper function to get line number from character position
        function getLineNumber(content, position) {
            const beforePosition = content.substring(0, position);
            return beforePosition.split('\n').length;
        }

        // Helper function to get context with line numbers and formatted code
        function getContextWithLineNumber(content, position, contextLines = 2) {
            const lines = content.split('\n');
            const targetLineIndex = getLineNumber(content, position) - 1; // Convert to 0-based index

            // Calculate the range of lines to show
            const startLine = Math.max(0, targetLineIndex - contextLines);
            const endLine = Math.min(lines.length - 1, targetLineIndex + contextLines);

            // Build the formatted context with line numbers on the same line
            let formattedContext = '';
            for (let i = startLine; i <= endLine; i++) {
                const lineNumber = (i + 1).toString().padStart(3, ' '); // 3-digit line numbers
                const indicator = i === targetLineIndex ? '‚Üí' : ' '; // Arrow points to the problem line
                const line = (lines[i] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML

                // Add special formatting for the problem line
                if (i === targetLineIndex) {
                    formattedContext += `<span style="color: #f56565; font-weight: bold;">${lineNumber}${indicator}</span> ${line}\n`;
                } else {
                    formattedContext += `<span style="color: #a0aec0;">${lineNumber}${indicator}</span> ${line}\n`;
                }
            }

            return {
                lineNumber: targetLineIndex + 1, // Convert back to 1-based
                context: content.substring(Math.max(0, position - 50), position + 100).replace(/\n/g, ' '), // Single line context for backwards compatibility
                formattedContext: formattedContext.trim() // Multi-line context with line numbers
            };
        }

        // Client-side style tag validation function
        function validateStyleTags(htmlContent) {
            const errors = [];
            const warnings = [];

            log('üîç Validating style tags in HTML content...');

            // Simple bracket validation
            const bracketErrors = [];

            // Find all bracket sequences that look like style tags
            const allBracketPatterns = /\[+(?:style:\s*[\w]+|\/style)\]+/gi;
            
            let match;
            while ((match = allBracketPatterns.exec(htmlContent)) !== null) {
                const found = match[0];
                const contextInfo = getContextWithLineNumber(htmlContent, match.index);
                let expectedFormat, errorType;
                
                // Determine what it should be and if it's correct
                if (found.includes('style:')) {
                    // Extract the style type (e.g., "read", "image", etc.)
                    const styleMatch = found.match(/style:\s*([\w]+)/i);
                    const styleType = styleMatch ? styleMatch[1] : 'xx';
                    
                    // Check if it's a valid format (allowing spaces after colon)
                    const validPattern = new RegExp(`^\\[\\[style:\\s*${styleType}\\]\\]$`, 'i');
                    const isValidFormat = validPattern.test(found);
                    
                    if (!isValidFormat) {
                        // Only report as error if it's actually malformed (wrong brackets, not just spacing)
                        expectedFormat = `[[style:${styleType}]]`;
                        errorType = 'malformed_opening_tag';
                        bracketErrors.push({
                            type: errorType,
                            message: `Malformed opening tag: ${found} should be ${expectedFormat}`,
                            position: match.index,
                            line: contextInfo.lineNumber,
                            context: contextInfo.formattedContext,
                            found: found,
                            expected: expectedFormat
                        });
                        log(`‚ùå Malformed opening tag found: ${found} at line ${contextInfo.lineNumber}`);
                    }
                } else if (found.includes('/style')) {
                    expectedFormat = '[[/style]]';
                    
                    if (found !== expectedFormat) {
                        errorType = 'malformed_closing_tag';
                        bracketErrors.push({
                            type: errorType,
                            message: `Malformed closing tag: ${found} should be ${expectedFormat}`,
                            position: match.index,
                            line: contextInfo.lineNumber,
                            context: contextInfo.formattedContext,
                            found: found,
                            expected: expectedFormat
                        });
                        log(`‚ùå Malformed closing tag found: ${found} at line ${contextInfo.lineNumber}`);
                    }
                }
            }

            // Add bracket errors to the main errors array
            log(`üîç Found ${bracketErrors.length} bracket errors`);
            bracketErrors.forEach((error, index) => {
                log(`  ${index + 1}. [${error.type}] ${error.message} at line ${error.line}`);
                errors.push(error);
            });

            // Detailed opening/closing tag validation with stack-based matching
            const openingTags = [];
            const closingTags = [];
            
            // Find all opening tags with their positions and types
            const openingPattern = /\[\[style:\s*([\w]+)\]\]/gi;
            let openMatch;
            while ((openMatch = openingPattern.exec(htmlContent)) !== null) {
                const styleType = openMatch[1] ? openMatch[1].toLowerCase() : 'unknown';
                openingTags.push({
                    type: styleType,
                    fullMatch: openMatch[0],
                    position: openMatch.index,
                    line: getLineNumber(htmlContent, openMatch.index)
                });
                log(`‚úÖ Found opening: [[style:${styleType}]] at line ${getLineNumber(htmlContent, openMatch.index)}`);
            }
            
            // Find all closing tags with their positions
            const closingPattern = /\[\[\/style\]\]/gi;
            let closeMatch;
            while ((closeMatch = closingPattern.exec(htmlContent)) !== null) {
                closingTags.push({
                    fullMatch: closeMatch[0],
                    position: closeMatch.index,
                    line: getLineNumber(htmlContent, closeMatch.index)
                });
                log(`‚úÖ Found closing: [[/style]] at line ${getLineNumber(htmlContent, closeMatch.index)}`);
            }
            
            log(`üìä Style tag summary: ${openingTags.length} opening, ${closingTags.length} closing`);
            
            // Stack-based validation to find unmatched tags
            if (openingTags.length > 0 || closingTags.length > 0) {
                // Create combined array of all tags sorted by position
                const allTags = [];
                
                openingTags.forEach(tag => {
                    allTags.push({ ...tag, tagType: 'opening' });
                });
                
                closingTags.forEach(tag => {
                    allTags.push({ ...tag, tagType: 'closing', type: 'closing' });
                });
                
                // Sort by position
                allTags.sort((a, b) => a.position - b.position);
                
                // Process tags using stack-based validation
                const stack = [];
                const orphanedClosingTags = [];
                
                for (let i = 0; i < allTags.length; i++) {
                    const tag = allTags[i];
                    
                    if (tag.tagType === 'opening') {
                        stack.push(tag);
                        log(`üîç Found opening: [[style:${tag.type}]] at line ${tag.line} (position ${tag.position})`);
                    } else if (tag.tagType === 'closing') {
                        if (stack.length === 0) {
                            // Orphaned closing tag
                            const contextInfo = getContextWithLineNumber(htmlContent, tag.position);
                            orphanedClosingTags.push({
                                position: tag.position,
                                line: contextInfo.lineNumber,
                                context: contextInfo.formattedContext
                            });
                        } else {
                            // Match with most recent opening tag
                            const openingTag = stack.pop();
                            log(`‚úÖ Matched: [[style:${openingTag.type}]] (line ${openingTag.line}) with [[/style]] (line ${tag.line})`);
                        }
                    }
                }
                
                // Handle orphaned closing tags
                if (orphanedClosingTags.length > 0) {
                    const errorMsg = {
                        type: 'orphaned_closing',
                        message: `${orphanedClosingTags.length} orphaned closing tag${orphanedClosingTags.length > 1 ? 's' : ''} [[/style]] found with no matching opening tag${orphanedClosingTags.length > 1 ? 's' : ''}.`,
                        context: orphanedClosingTags.map(tag => 
                            `[[/style]] at line ${tag.line}\n${tag.context}`
                        ).join('\n\n')
                    };
                    errors.push(errorMsg);
                    log(`‚ùå ERROR: ${errorMsg.message}`);
                }
                
                // Handle unclosed opening tags (missing closing tags)
                if (stack.length > 0) {
                    // Create individual errors for each unclosed opening tag
                    stack.forEach(unclosedTag => {
                        const contextInfo = getContextWithLineNumber(htmlContent, unclosedTag.position);
                        const errorMsg = {
                            type: 'missing_closing',
                            message: `Opening tag [[style:${unclosedTag.type}]] at line ${contextInfo.lineNumber} is missing its closing tag [[/style]].`,
                            context: contextInfo.formattedContext
                        };
                        errors.push(errorMsg);
                        log(`‚ùå ERROR: Opening tag [[style:${unclosedTag.type}]] at line ${contextInfo.lineNumber} missing closing tag`);
                    });
                }
            }

            return { errors, warnings };
        }

        // Function to display style validation errors with formatted code
        function showStyleValidationErrors(errors, htmlContent) {
            // Create modal HTML
            const modalHtml = `
                <div id="errorModal" style="
                    position: fixed; 
                    top: 0; 
                    left: 0; 
                    width: 100%; 
                    height: 100%; 
                    background: rgba(0,0,0,0.7); 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    z-index: 10000;
                ">
                    <div style="
                        background: white; 
                        padding: 30px; 
                        border-radius: 10px; 
                        max-width: 80vw; 
                        max-height: 80vh; 
                        overflow-y: auto;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e74c3c; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #e74c3c; font-size: 1.5rem;">
                                ‚ùå Style Tag Validation Failed
                            </h2>
                            <button onclick="closeErrorModal()" style="
                                background: #e74c3c; 
                                color: white; 
                                border: none; 
                                padding: 8px 15px; 
                                border-radius: 5px; 
                                cursor: pointer; 
                                font-size: 1rem;
                            ">‚úñ Close</button>
                        </div>
                        <p style="margin-bottom: 20px; color: #333; font-size: 1.1rem;">
                            Found <strong>${errors.length}</strong> error${errors.length > 1 ? 's' : ''} in your HTML document:
                        </p>
                        <div id="errorList"></div>
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #17a2b8;">
                            <p style="margin: 0; color: #17a2b8; font-weight: bold;">üí° How to fix:</p>
                            <p style="margin: 5px 0 0 0; color: #333; font-size: 0.95rem;">
                                Edit your Word or HTML document to fix the issues shown above, then try uploading again. 
                            </p>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Populate error list
            const errorList = document.getElementById('errorList');
            errors.forEach((error, index) => {
                const errorDiv = document.createElement('div');
                errorDiv.style.marginBottom = '25px';
                errorDiv.style.padding = '15px';
                errorDiv.style.border = '1px solid #dc3545';
                errorDiv.style.borderRadius = '5px';
                errorDiv.style.backgroundColor = '#fff5f5';
                
                // Handle structured error object or legacy string format
                let errorMessage, codeContext;
                
                if (typeof error === 'object' && error.message) {
                    // New structured format
                    errorMessage = error.message;
                    codeContext = error.codeContext || error.context || '';
                } else {
                    // Legacy string format (fallback)
                    const parts = error.split('\n\nCode context:\n');
                    errorMessage = parts[0];
                    codeContext = parts[1] || '';
                }
                
                errorDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #dc3545; font-size: 1.1rem;">
                        Error ${index + 1}:
                    </h4>
                    <p style="margin: 0 0 15px 0; color: #333; font-size: 1rem; line-height: 1.4;">
                        ${errorMessage}
                    </p>
                    ${codeContext ? `
                        <div style="margin-top: 15px;">
                            <p style="margin: 0 0 8px 0; font-weight: bold; color: #495057; font-size: 0.95rem;">Code context:</p>
                            <pre style="
                                background: #2d3748; 
                                border: 1px solid #4a5568; 
                                border-radius: 6px; 
                                padding: 16px; 
                                margin: 0; 
                                font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; 
                                font-size: 0.85rem; 
                                line-height: 1.5; 
                                color: #e2e8f0;
                                overflow-x: auto;
                                white-space: pre;
                                text-align: left;
                                tab-size: 4;
                            ">${codeContext}</pre>
                        </div>
                    ` : ''}
                `;
                
                errorList.appendChild(errorDiv);
            });
            
            // Add global close function
            window.closeErrorModal = function() {
                const modal = document.getElementById('errorModal');
                if (modal) {
                    modal.remove();
                    delete window.closeErrorModal;
                }
            };
            
            // Close on background click
            document.getElementById('errorModal').addEventListener('click', function(e) {
                if (e.target.id === 'errorModal') {
                    closeErrorModal();
                }
            });
        }

        // Progress tracking functions
        function updateProgress(percentage, text) {
            const button = document.getElementById('convertButton');
            const buttonText = document.getElementById('buttonText');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            buttonText.textContent = text;
            progressBar.style.display = 'block';
            progressFill.style.width = percentage + '%';
            
            // Disable button during processing
            button.disabled = true;
            button.style.opacity = '0.8';
            button.style.cursor = 'not-allowed';
        }

        function resetProgress() {
            const button = document.getElementById('convertButton');
            const buttonText = document.getElementById('buttonText');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            buttonText.textContent = 'üöÄ Convert Document';
            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
            
            // Re-enable button
            button.disabled = false;
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
        }

        async function convertDocument() {
            const webhookUrl = document.getElementById('webhookUrl').value;
            const fileInput = document.getElementById('document');
            let learningOutcome = ''; // Default empty since input field was removed

            if (!webhookUrl || !fileInput.files[0]) {
                log(MESSAGES.MISSING_FIELDS);
                return;
            }

            // Validate file type before processing
            if (!validateFileType()) {
                return;
            }

            // Start progress tracking
            updateProgress(10, 'üîÑ Starting conversion...');
            log(MESSAGES.CONVERSION_START);

            try {
                const file = fileInput.files[0];
                updateProgress(20, 'üìÑ Reading file...');
                log(`üìÑ Reading file: ${file.name} (${file.size} bytes)`);

                const htmlContent = await file.text();
                updateProgress(30, '‚úÖ File loaded, validating...');
                log(`‚úÖ File content loaded (${htmlContent.length} characters)`);

                // CLIENT-SIDE STYLE TAG VALIDATION
                updateProgress(40, 'üîç Validating style tags...');
                log('üîç Performing client-side style tag validation...');
                const validation = validateStyleTags(htmlContent);
                
                if (validation.errors.length > 0) {
                    resetProgress();
                    log('‚ùå Style tag validation failed!');
                    
                    log(`Found ${validation.errors.length} total error${validation.errors.length > 1 ? 's' : ''}`);
                    validation.errors.forEach((error, index) => {
                        const errorType = error.type ? `[${error.type}]` : '';
                        log(`${index + 1}. ${errorType} ${error.message || error}`);
                    });
                    
                    // Show detailed error message to user with formatted code
                    showStyleValidationErrors(validation.errors, htmlContent);
                    
                    log('üí° Upload cancelled - please fix style tag issues and try again');
                    return; // Stop processing here
                }
                
                if (validation.warnings.length > 0) {
                    updateProgress(50, '‚ö†Ô∏è Validation completed with warnings');
                    log(`‚ö†Ô∏è Style tag validation completed with ${validation.warnings.length} warning(s):`);
                    validation.warnings.forEach((warning, index) => {
                        log(`${index + 1}. ${warning}`);
                    });
                } else {
                    updateProgress(50, '‚úÖ Validation passed');
                    log('‚úÖ Style tag validation passed - no errors found');
                }

                // Auto-detect LO number from filename
                updateProgress(60, 'üîç Processing file details...');
                const loMatch = file.name.match(/LO(\d+)/i);
                if (loMatch) {
                    learningOutcome = loMatch[1].padStart(2, '0');
                    log(`üîç Auto-detected LO number from filename: ${learningOutcome}`);
                } else {
                    log(`üí° No LO number found in filename, workflow will use default`);
                }

                const payload = {
                    htmlContent: htmlContent,
                    fileName: file.name,
                    learningOutcome: learningOutcome
                };

                updateProgress(70, 'üì§ Sending to n8n...');
                log('üì§ Sending to n8n...');
                log(`Payload size: ${JSON.stringify(payload).length} characters`);

                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                updateProgress(80, 'üì• Processing response...');
                log(`üì• Response received: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    resetProgress();
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                updateProgress(90, 'üîÑ Parsing results...');
                const result = await response.json();
                latestResult = result; // Store for download functionality

                updateProgress(100, '‚úÖ Conversion complete!');
                log('‚úÖ Conversion successful!');
                log(`Response data: ${JSON.stringify(result, null, 2)}`);
                
                // Debug: Check the actual structure of the response
                console.log('Full response:', result);
                console.log('Files array:', result.files);
                if (result.files && result.files.length > 0) {
                    console.log('First file structure:', result.files[0]);
                    console.log('First file keys:', Object.keys(result.files[0]));
                    console.log('First file content preview:', result.files[0].content?.substring(0, 50) || 'NO CONTENT');
                    console.log('First file data preview:', result.files[0].data?.substring(0, 50) || 'NO DATA');
                }

                // Display results
                displayResults(result);

                // Reset progress after a short delay to show completion
                setTimeout(() => {
                    resetProgress();
                }, 2000);

            } catch (error) {
                resetProgress();
                log(`‚ùå Conversion failed: ${error.message}`);
                console.error('Conversion error:', error);
            }
        }

        function displayResults(result) {
            // Store result globally for ZIP download
            latestResult = result;

            const resultsDiv = document.getElementById('results');
            const fileList = document.getElementById('fileList');

            fileList.innerHTML = '';

            // Handle different response structures like the backup does
            let actualData = result;
            
            // Check if response is wrapped (common with n8n)
            if (result.data) {
                actualData = result.data;
            } else if (Array.isArray(result) && result.length > 0) {
                actualData = result[0];
            }

            if (actualData.success && actualData.folderPath) {
                // Display folder location and summary - working format from backup
                const folderInfo = document.createElement('div');
                folderInfo.style.padding = '20px';
                folderInfo.style.margin = '10px 0';
                folderInfo.style.backgroundColor = '#d4edda';
                folderInfo.style.borderRadius = '5px';
                folderInfo.style.border = '1px solid #c3e6cb';

                folderInfo.innerHTML = `
                    <h4>üìÅ Files Generated Successfully!</h4>
                    <p><strong>Total Files:</strong> ${actualData.totalFiles}</p>
                    <p><strong>TAR archive:</strong> ${actualData.folderName}.tar</p>
                    <p><strong>Generated:</strong> ${new Date(actualData.processingDate).toLocaleString()}</p>
                    <p>You can click <strong>Generated HTML Files</strong> below to view or download individual HTML files, or download in the <strong>Step 4: Download Results</strong> section.</p>
                `;

                fileList.appendChild(folderInfo);

                // Display generated HTML files list alphabetically
                if (actualData.files && actualData.files.length > 0) {
                    const filesListDiv = document.createElement('div');
                    filesListDiv.style.padding = '20px';
                    filesListDiv.style.margin = '10px 0';
                    filesListDiv.style.backgroundColor = '#f8f9fa';
                    filesListDiv.style.borderRadius = '5px';
                    filesListDiv.style.border = '1px solid #dee2e6';

                    // Separate files into three categories
                    const recognizedFiles = [];
                    const mediaRequestFiles = [];
                    const problematicFiles = [];

                    actualData.files.forEach((file, index) => {
                        file.originalIndex = index;

                        // Check if it's a media/graphic/interactive request file
                        if (file.fileName.includes('media_graphics_interactive_requests') ||
                            file.fileName.includes('request-tables')) {
                            mediaRequestFiles.push(file);
                        }
                        // Check if file can be detected as LO/LS/LA file based on naming pattern
                        else if (file.fileName.match(/^\d{2}_\d{2}_\d{2}_/) ||
                            file.fileName.includes('learning-outcome') ||
                            file.fileName.includes('learning-step') ||
                            file.fileName.includes('learning-activity')) {
                            recognizedFiles.push(file);
                        }
                        // Only add to problematic if it's not a request file AND has no LO/LS/LA info
                        else {
                            problematicFiles.push(file);
                        }
                    });

                    let filesHTML = '<button onclick="toggleGeneratedFiles()" style="background-color: #007bff; color: white; padding: 15px; width: 100%; border: none; border-radius: 8px; font-size: 1.1rem; font-weight: bold; cursor: pointer; margin: 10px 0; display: flex; justify-content: space-between; align-items: center;"><span id="filesToggleText">üìÑ Generated HTML Files (Click to show)</span> <span id="filesToggleIcon">‚ûï</span></button>';
                    filesHTML += '<div id="filesContainer" style="display: none; padding: 20px; background-color: #f8f9fa; border-radius: 0 0 8px 8px; border: 1px solid #dee2e6;">';

                    // Sort recognized files alphabetically
                    const sortedRecognizedFiles = recognizedFiles.sort((a, b) => a.fileName.localeCompare(b.fileName));

                    if (sortedRecognizedFiles.length > 0) {
                        filesHTML += '<div style="margin-top: 15px;">';
                        sortedRecognizedFiles.forEach(file => {
                            filesHTML += `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; margin: 5px 0; background: white; border-radius: 5px; border: 1px solid #e0e0e0;">
                                    <div style="flex: 1;">
                                        <strong>${file.fileName}</strong>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-info" style="padding: 5px 10px; font-size: 0.8rem;" onclick="previewFile(${file.originalIndex})">
                                            üëÅÔ∏è Preview
                                        </button>
                                        <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.8rem;" onclick="viewFileCode(${file.originalIndex})">
                                            üìù View Code
                                        </button>
                                        <button class="btn btn-success" style="padding: 5px 10px; font-size: 0.8rem;" onclick="downloadSingleFile(${file.originalIndex})">
                                            üíæ Download
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        filesHTML += '</div>';
                    }

                    // Add media request files section if any exist
                    if (mediaRequestFiles.length > 0) {
                        const sortedMediaRequestFiles = mediaRequestFiles.sort((a, b) => a.fileName.localeCompare(b.fileName));
                        filesHTML += '<h5 style="margin-top: 20px; color: #17a2b8;">üìã LO media requests:</h5>';
                        filesHTML += '<div style="margin-top: 10px;">';
                        sortedMediaRequestFiles.forEach(file => {
                            filesHTML += `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; margin: 5px 0; background: #e7f3ff; border-radius: 5px; border: 1px solid #bee5eb;">
                                    <div style="flex: 1;">
                                        <strong>${file.fileName}</strong>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-info" style="padding: 5px 10px; font-size: 0.8rem;" onclick="previewFile(${file.originalIndex})">
                                            üëÅÔ∏è Preview
                                        </button>
                                        <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.8rem;" onclick="viewFileCode(${file.originalIndex})">
                                            üìù View Code
                                        </button>
                                        <button class="btn btn-success" style="padding: 5px 10px; font-size: 0.8rem;" onclick="downloadSingleFile(${file.originalIndex})">
                                            üíæ Download
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        filesHTML += '</div>';
                    }

                    // Add problematic files section if any exist
                    if (problematicFiles.length > 0) {
                        const sortedProblematicFiles = problematicFiles.sort((a, b) => a.fileName.localeCompare(b.fileName));
                        filesHTML += '<h5 style="margin-top: 20px; color: #dc3545;">‚ö†Ô∏è Files with problematic activity header. Double check the Header 1 style in the Word document and convert again.</h5>';
                        filesHTML += '<div style="margin-top: 10px;">';
                        sortedProblematicFiles.forEach(file => {
                            filesHTML += `
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; margin: 5px 0; background: #fff5f5; border-radius: 5px; border: 1px solid #fed7d7;">
                                    <div style="flex: 1;">
                                        <strong>${file.fileName}</strong>
                                    </div>
                                    <div style="display: flex; gap: 8px;">
                                        <button class="btn btn-info" style="padding: 5px 10px; font-size: 0.8rem;" onclick="previewFile(${file.originalIndex})">
                                            üëÅÔ∏è Preview
                                        </button>
                                        <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 0.8rem;" onclick="viewFileCode(${file.originalIndex})">
                                            üìù View Code
                                        </button>
                                        <button class="btn btn-success" style="padding: 5px 10px; font-size: 0.8rem;" onclick="downloadSingleFile(${file.originalIndex})">
                                            üíæ Download
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        filesHTML += '</div>';
                    }

                    filesHTML += '</div>'; // Close filesContainer
                    filesListDiv.innerHTML = filesHTML;
                    fileList.appendChild(filesListDiv);
                }

                // Add Step 3: Download section
                const downloadStepDiv = document.createElement('div');
                downloadStepDiv.style.padding = '15px';
                downloadStepDiv.style.margin = '10px 0';
                downloadStepDiv.style.backgroundColor = '#e7f3ff';
                downloadStepDiv.style.borderRadius = '5px';
                downloadStepDiv.style.border = '1px solid #0066cc';
                downloadStepDiv.style.textAlign = 'center';

                downloadStepDiv.innerHTML = `
                    <div class="step-header">
                        <div class="step-number">4</div>
                        <h3 class="step-title">Download Results</h3>
                    </div>
                    <div class="alert alert-success">
                        <p><strong>‚úÖ Processing Complete!</strong> Choose your download option below.</p>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin: 1rem 0;">
                        <button class="btn btn-warning" onclick="downloadAsTar()">
                            üì¶ Download TAR Archive (${actualData.totalFiles} Files)
                        </button>
                    </div>
                    <div id="downloadProgress" style="margin-top: 1rem; display: none;">
                        <div class="progress-container">
                            <div id="progressBar" class="progress-bar" style="width: 0%;"></div>
                        </div>
                        <p id="progressText" style="margin: 0.5rem 0; font-size: 0.9rem; color: #666; text-align: center;"></p>
                    </div>
                `;

                fileList.appendChild(downloadStepDiv);

                resultsDiv.style.display = 'block';
                
            } else {
                // Handle old format or errors
                const errorDiv = document.createElement('div');
                errorDiv.style.padding = '20px';
                errorDiv.style.margin = '10px 0';
                errorDiv.style.backgroundColor = '#f8d7da';
                errorDiv.innerHTML = `
                    <h4>‚ùå Unexpected Response Format</h4>
                    <p>The workflow may be using an older format. Check the debug log for details.</p>
                `;
                fileList.appendChild(errorDiv);
                resultsDiv.style.display = 'block';
            }
        }

        function toggleFileList() {
            const content = document.getElementById('fileListContent');
            const button = content.previousElementSibling;
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                button.classList.add('active');
            } else {
                content.style.display = 'none';
                button.classList.remove('active');
            }
        }

        function previewFile(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for preview');
                return;
            }

            const file = latestResult.files[index];
            log(`üëÅÔ∏è Opening preview for: ${file.fileName}`);

            // Create preview window
            const previewWindow = window.open('', '_blank', 'width=1000,height=700,scrollbars=yes,resizable=yes');
            
            if (!previewWindow) {
                alert('Popup blocked! Please allow popups for this site to preview files.');
                return;
            }

            // Write the HTML content to the preview window using template literal
            const htmlContent = file.content || file.htmlContent || file.data || '';
            const previewHtml = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Preview: ${file.fileName}</title>
                    <link rel="stylesheet" href="https://online.saskpolytech.ca/shared/sp-template/styles/SP-Global-2015.css">
                    <style>
                        body { 
                            padding: 20px; 
                            font-family: Arial, sans-serif; 
                        }
                        .preview-header { 
                            background: #f8f9fa; 
                            padding: 15px; 
                            border-radius: 5px; 
                            margin-bottom: 20px;
                            border-left: 4px solid #007bff;
                        }
                        .preview-content { 
                            border: 1px solid #dee2e6; 
                            border-radius: 5px; 
                            padding: 20px;
                            background: white;
                        }
                    </style>
                </head>
                <body>
                    <div class="preview-header">
                        <h2>üìÑ Preview: ${file.fileName}</h2>
                        <p><strong>Size:</strong> ${UTILS.formatFileSize(file.size || htmlContent.length || 0)}</p>
                        <button onclick="window.close()" style="
                            background: #6c757d; 
                            color: white; 
                            border: none; 
                            padding: 8px 16px; 
                            border-radius: 4px; 
                            cursor: pointer;
                        ">‚úñ Close Preview</button>
                    </div>
                    <div class="preview-content">
                        ${htmlContent}
                    </div>
                </body>
                </html>
            `;
            previewWindow.document.write(previewHtml);
            
            previewWindow.document.close();
            log(`‚úÖ Preview opened for: ${file.fileName}`);
        }

        function viewCode(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for code view');
                return;
            }

            const file = latestResult.files[index];
            log(`üìù Opening code view for: ${file.fileName}`);

            // Create code view window
            const codeWindow = window.open('', '_blank', 'width=1000,height=700,scrollbars=yes,resizable=yes');
            
            if (!codeWindow) {
                alert('Popup blocked! Please allow popups for this site to view code.');
                return;
            }

            const htmlContent = file.content || file.htmlContent || file.data || '';

            const htmlEscapedContent = htmlContent.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            const codeViewHtml = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Code View: ${file.fileName}</title>
                    <style>
                        body { 
                            font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace; 
                            margin: 0; 
                            padding: 20px; 
                            background: #f8f9fa; 
                        }
                        .code-header { 
                            background: #2d3748; 
                            color: white; 
                            padding: 15px; 
                            border-radius: 5px 5px 0 0; 
                            display: flex; 
                            justify-content: space-between; 
                            align-items: center; 
                        }
                        .code-content { 
                            background: #2d3748; 
                            color: #e2e8f0; 
                            padding: 20px; 
                            border-radius: 0 0 5px 5px; 
                            overflow-x: auto; 
                            white-space: pre; 
                            line-height: 1.5; 
                            max-height: 600px; 
                            overflow-y: auto; 
                        }
                        .copy-btn { 
                            background: #007bff; 
                            color: white; 
                            border: none; 
                            padding: 8px 16px; 
                            border-radius: 4px; 
                            cursor: pointer; 
                            margin-left: 10px; 
                        }
                        .copy-btn:hover { 
                            background: #0056b3; 
                        }
                        .close-btn { 
                            background: #6c757d; 
                            color: white; 
                            border: none; 
                            padding: 8px 16px; 
                            border-radius: 4px; 
                            cursor: pointer; 
                        }
                        .close-btn:hover { 
                            background: #545b62; 
                        }
                        /* Collapsible styles */
                        .collapsible {
                            background-color: #f8f9fa;
                            color: #495057;
                            cursor: pointer;
                            padding: 18px;
                            width: 100%;
                            border: none;
                            text-align: left;
                            outline: none;
                            font-size: 1.1rem;
                            font-weight: bold;
                            margin: 10px 0;
                            border-radius: 8px;
                            transition: background-color 0.3s ease;
                        }
                        .collapsible:hover {
                            background-color: #e9ecef;
                        }
                        .collapsible.active {
                            background-color: #007bff;
                            color: white;
                        }
                        .collapsible::after {
                            content: '‚ûï';
                            float: right;
                            margin-left: 5px;
                        }
                        .collapsible.active::after {
                            content: '‚ûñ';
                        }
                        .content {
                            padding: 0 18px;
                            max-height: 0;
                            overflow: hidden;
                            transition: max-height 0.3s ease-out;
                            background-color: #f8f9fa;
                            border-radius: 0 0 8px 8px;
                        }
                        .content.active {
                            max-height: none;
                        }
                    </style>
                </head>
                <body>
                    <div class="code-header">
                        <div>
                            <h3 style="margin: 0;">üìù ${file.fileName}</h3>
                            <small>${UTILS.formatFileSize(file.size || htmlContent.length)}</small>
                        </div>
                        <div>
                            <button class="copy-btn" onclick="copyToClipboard()">üìã Copy Code</button>
                            <button class="close-btn" onclick="window.close()">‚úñ Close</button>
                        </div>
                    </div>
                    <div class="code-content" id="codeContent">${htmlEscapedContent}</div>
                    <script>
                        function copyToClipboard() { 
                            const codeContent = document.getElementById("codeContent").textContent; 
                            navigator.clipboard.writeText(codeContent).then(function() { 
                                const btn = document.querySelector(".copy-btn"); 
                                const originalText = btn.textContent; 
                                btn.textContent = "‚úÖ Copied!"; 
                                btn.style.background = "#28a745"; 
                                setTimeout(function() { 
                                    btn.textContent = originalText; 
                                    btn.style.background = "#007bff"; 
                                }, 2000); 
                            }).catch(function(err) { 
                                alert("Failed to copy to clipboard"); 
                            }); 
                        }
                    <\/script>
                </body>
                </html>
            `;
            
            codeWindow.document.write(codeViewHtml);
            codeWindow.document.close();
            log('‚úÖ Code view opened for: ' + file.fileName);
        }

        function downloadFile(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for download');
                return;
            }

            const file = latestResult.files[index];
            const content = file.content || file.htmlContent || file.data || '';
            
            const blob = new Blob([content], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = file.fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log(`üíæ Downloaded: ${file.fileName}`);
        }

        // Create TAR file - alternative to ZIP that might bypass Windows security
        function downloadAsTar() {
            if (!latestResult || !latestResult.files || latestResult.files.length === 0) {
                log('‚ùå No files available for TAR download');
                return;
            }

            log('üì¶ Creating TAR archive (Windows-friendly alternative to ZIP)...');

            try {
                const folderName = latestResult.folderName;
                const tarData = [];

                // Create README file content
                const readmeContent = `# ${folderName} - Generated HTML Files
                
Generated on: ${new Date().toLocaleString()}
Total files: ${latestResult.files.length}
Source: CMP Document Converter

## File Structure:
${latestResult.files.map(f => `- ${f.fileName} (${f.type})`).join('\n')}

## Usage:
These HTML files are ready to be uploaded to Brightspace or your LMS.
Each file represents a section from your original document.

## Organization:
All files are contained in the ${folderName} folder structure.

## Extraction:
Use 7-Zip, WinRAR, or similar tool to extract this TAR archive.
`;

                // Add README to TAR
                addFileToTar(tarData, 'README.txt', readmeContent);
                log('üìÑ Added README.txt to TAR');

                // Add each HTML file to TAR
                latestResult.files.forEach(file => {
                    // Extract HTML content from base64 data URL
                    const base64Data = file.downloadUrl.split(',')[1];
                    const htmlContent = atob(base64Data);

                    // Add file to TAR with folder structure
                    addFileToTar(tarData, `${folderName}/${file.fileName}`, htmlContent);
                    log(`üìÑ Added to TAR: ${file.fileName}`);
                });

                // Add TAR end-of-archive marker (two 512-byte zero blocks)
                tarData.push(new Uint8Array(512));
                tarData.push(new Uint8Array(512));

                log('üîÑ Generating TAR file...');

                // Create TAR file blob
                const tarBlob = new Blob(tarData, { type: 'application/x-tar' });

                // Download TAR file
                const downloadUrl = window.URL.createObjectURL(tarBlob);
                const downloadLink = document.createElement('a');
                downloadLink.href = downloadUrl;
                downloadLink.download = `${folderName}.tar`;
                downloadLink.style.display = 'none';

                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                window.URL.revokeObjectURL(downloadUrl);

                log(`‚úÖ TAR download started: ${folderName}.tar`);
                log(`üì¶ TAR contains ${latestResult.files.length} files + README in ${folderName} folder`);
                log(`üîß Extract with 7-Zip, WinRAR, or similar tool`);
                log(`üí° TAR format is less likely to be blocked by Windows security`);

            } catch (error) {
                log(`‚ùå TAR creation failed: ${error.message}`);
                log(`üí° Fallback: Use individual download links below`);
            }
        }

        // Helper function to add a file to TAR data
        function addFileToTar(tarData, fileName, content) {
            const fileData = new TextEncoder().encode(content);
            const header = createTarHeader(fileName, fileData.length);

            tarData.push(header);
            tarData.push(fileData);

            // Pad to 512-byte boundary
            const padding = 512 - (fileData.length % 512);
            if (padding !== 512) {
                tarData.push(new Uint8Array(padding));
            }
        }

        // Create TAR header (512 bytes)
        function createTarHeader(fileName, fileSize) {
            const header = new Uint8Array(512);
            const encoder = new TextEncoder();

            // File name (100 bytes)
            const nameBytes = encoder.encode(fileName);
            header.set(nameBytes.slice(0, 100), 0);

            // File mode (8 bytes) - 644 in octal
            const mode = '0000644\0';
            header.set(encoder.encode(mode), 100);

            // Owner ID (8 bytes)
            const uid = '0000000\0';
            header.set(encoder.encode(uid), 108);

            // Group ID (8 bytes)
            const gid = '0000000\0';
            header.set(encoder.encode(gid), 116);

            // File size (12 bytes)
            const size = fileSize.toString(8).padStart(11, '0') + '\0';
            header.set(encoder.encode(size), 124);

            // Modification time (12 bytes)
            const mtime = Math.floor(Date.now() / 1000).toString(8).padStart(11, '0') + '\0';
            header.set(encoder.encode(mtime), 136);

            // Type flag (1 byte) - regular file
            header[156] = 48; // '0' for regular file

            // Calculate and set checksum
            const checksum = calculateTarChecksum(header);
            const checksumStr = checksum.toString(8).padStart(6, '0') + '\0 ';
            header.set(encoder.encode(checksumStr), 148);

            return header;
        }

        // Calculate TAR checksum
        function calculateTarChecksum(header) {
            // Clear checksum field for calculation
            for (let i = 148; i < 156; i++) {
                header[i] = 32; // space character
            }

            let sum = 0;
            for (let i = 0; i < 512; i++) {
                sum += header[i];
            }

            return sum;
        }

        // Functions for individual file operations
        function previewFile(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for preview');
                return;
            }

            const file = latestResult.files[index];
            const previewWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');

            if (previewWindow) {
                // Extract HTML content from base64 data URL or direct content
                let htmlContent;
                if (file.downloadUrl && file.downloadUrl.startsWith('data:')) {
                    const base64Data = file.downloadUrl.split(',')[1];
                    htmlContent = atob(base64Data);
                } else if (file.content) {
                    htmlContent = file.content;
                } else {
                    htmlContent = '<p>No content available for preview</p>';
                }

                previewWindow.document.write(htmlContent);
                previewWindow.document.close();
                log(`üëÅÔ∏è Opened preview for: ${file.fileName}`);
            } else {
                log('‚ùå Could not open preview window. Please allow popups for this site.');
            }
        }

        function viewFileCode(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for code view');
                return;
            }

            const file = latestResult.files[index];
            const codeWindow = window.open('', '_blank', 'width=900,height=700,scrollbars=yes,resizable=yes');

            if (codeWindow) {
                // Extract HTML content from base64 data URL or direct content
                let htmlContent;
                if (file.downloadUrl && file.downloadUrl.startsWith('data:')) {
                    const base64Data = file.downloadUrl.split(',')[1];
                    htmlContent = atob(base64Data);
                } else if (file.content) {
                    htmlContent = file.content;
                } else {
                    htmlContent = 'No content available';
                }

                codeWindow.document.write('<!DOCTYPE html><html><head><title>Source Code: ' + file.fileName + '</title>');
                codeWindow.document.write('<style>body{font-family:Consolas,Monaco,monospace;margin:20px;background:#f8f9fa}');
                codeWindow.document.write('.header{background:#2F5496;color:white;padding:15px;margin:-20px -20px 20px -20px}');
                codeWindow.document.write('pre{background:white;padding:20px;border-radius:5px;border:1px solid #dee2e6;overflow-x:auto;white-space:pre-wrap}');
                codeWindow.document.write('.copy-btn{background:#28a745;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;margin-bottom:10px}');
                codeWindow.document.write('</style></head><body>');
                codeWindow.document.write('<div class="header"><h2>Source Code: ' + file.fileName + '</h2></div>');
                codeWindow.document.write('<button class="copy-btn" onclick="navigator.clipboard.writeText(document.getElementById(\'code\').textContent)">Copy Code</button>');
                codeWindow.document.write('<pre id="code">' + htmlContent.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</pre>');
                codeWindow.document.write('</body></html>');
                codeWindow.document.close();
                log('Code view opened for: ' + file.fileName);
            } else {
                log('Could not open code view window. Please allow popups.');
            }
        }

        function downloadSingleFile(index) {
            if (!latestResult || !latestResult.files || !latestResult.files[index]) {
                log('‚ùå File not found for download');
                return;
            }

            const file = latestResult.files[index];

            // Extract HTML content from base64 data URL or direct content
            let htmlContent;
            if (file.downloadUrl && file.downloadUrl.startsWith('data:')) {
                const base64Data = file.downloadUrl.split(',')[1];
                htmlContent = atob(base64Data);
            } else if (file.content) {
                htmlContent = file.content;
            } else {
                log('‚ùå No content available for download');
                return;
            }

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = window.URL.createObjectURL(blob);

            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = file.fileName;
            downloadLink.style.display = 'none';

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            window.URL.revokeObjectURL(url);
            log(`üíæ Downloaded: ${file.fileName}`);
        }

        // Simple toggle function for generated files
        function toggleGeneratedFiles() {
            const container = document.getElementById('filesContainer');
            const icon = document.getElementById('filesToggleIcon');
            const text = document.getElementById('filesToggleText');
            
            if (container.style.display === 'none') {
                container.style.display = 'block';
                icon.textContent = '‚ûñ';
                text.textContent = 'üìÑ Generated HTML Files (Click to hide)';
                log('üìÇ Revealed generated files');
            } else {
                container.style.display = 'none';
                icon.textContent = '‚ûï';
                text.textContent = 'üìÑ Generated HTML Files (Click to show)';
                log('üìÅ Hidden generated files');
            }
        }

        // Load saved webhook URL on page load
        window.onload = function() {
            const savedUrl = localStorage.getItem('webhookUrl');
            if (savedUrl) {
                document.getElementById('webhookUrl').value = savedUrl;
            }
        };

        // Save webhook URL to localStorage
        document.getElementById('webhookUrl').addEventListener('change', function () {
            localStorage.setItem('webhookUrl', this.value);
        });

        // Validate file type immediately when file is selected
        document.getElementById('document').addEventListener('change', function () {
            validateFileType();
        });

        // Simple toggle functionality - no complex initialization needed
    </script>
</body>

</html>