<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMP Document Converter</title>
    <link rel="stylesheet" href="css/cmp-doc-converter.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="js/cmp-doc-converter-config.js"></script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üîß CMP Document Converter</h1>
            <p>Transform your Word documents into Brightspace-ready HTML Files</p>
        </div>

        <div class="main-content">
            <div class="alert alert-info">
                <h3>üìã About This Tool</h3>
                <p>This tool converts CMP-ready Word documents into individual HTML files. Each H1 section becomes a
                    separate file optimized for Brightspace upload.</p>
                <p><strong>Important:</strong> Review all generated files and insert all media/interactives before
                    uploading to Brightspace.</p>
                <p>Refer to the <a href="docs/cmp-document-converter-instructions.html" target="_new"><strong>complete
                            instructions guide</strong></a> for detailed information on using this tool. </p>
            </div>

            <div class="step-card step-1">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <h3 class="step-title">Convert Word to HTML</h3>
                </div>
                <p><strong>Use Pandoc (recommended) or a similar converter to generate HTML from your LO Word
                        document.</strong></p>
                <p>Recommended pandoc command:</p>
                <div class="code-block">
                    <code>pandoc input.docx -s -o output.html --extract-media=. --ascii</code>
                </div>
                <p><em>This extracts media files and ensures ASCII compatibility for web use.</em></p>
            </div>

            <div class="step-card step-2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <h3 class="step-title">Test Connection</h3>
                </div>
                <div class="input-group">
                    <p>You can skip this step as it is for debugging only. Do not change the webhook URL unless
                        instructed to do so.</p>
                    <label for="webhookUrl">Webhook URL:</label>
                    <input type="url" id="webhookUrl"
                        value="https://learningtechnologies.app.n8n.cloud/webhook/cmp-document-upload">
                </div>
                <button class="btn btn-info" onclick="testWebhook()">üß™ Test Connection</button>
                <div id="testResult"></div>
            </div>

            <div class="step-card step-3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <h3 class="step-title">Upload & Convert</h3>
                </div>
                <div class="alert alert-warning" style="margin-bottom: 1rem;">
                    <strong>‚ö†Ô∏è Important:</strong> Only HTML files (.html, .htm) are accepted. Other file types will be
                    rejected automatically.
                </div>
                <div class="input-group">
                    <label for="document">Upload your HTML document using one of the methods below:</label>
                    <p style="margin: 0.5rem 0; color: #666; font-size: 0.9rem;">
                        <strong>Method 1:</strong> Drag and drop your HTML file into the area below<br>
                        <strong>Method 2:</strong> Click "Browse HTML Files" to select from your computer
                    </p>

                    <!-- Custom Drag & Drop File Area -->
                    <div class="file-drop-zone" id="fileDropZone" ondrop="handleDrop(event)"
                        ondragover="allowDrop(event)" ondragleave="handleDragLeave(event)">
                        <div class="drop-zone-content">
                            <div class="drop-zone-icon">üìÅ</div>
                            <div class="drop-zone-text">
                                <p><strong>Drag & Drop one HTML file here</strong></p>
                                <p class="drop-zone-or">or</p>
                                <button type="button" class="btn btn-secondary" onclick="triggerFileSelect()">
                                    üìÇ Browse HTML Files
                                </button>
                            </div>
                            <div class="drop-zone-hint">
                                <small>Only HTML files (.html, .htm) are accepted</small>
                            </div>
                        </div>
                    </div>

                    <!-- Hidden file input -->
                    <input type="file" id="document" accept=".html,.htm" style="display: none;"
                        title="Only HTML files (.html, .htm) are accepted">

                    <!-- Selected file display -->
                    <div id="selectedFileDisplay"
                        style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e8; border-radius: 5px; border: 1px solid #c3e6cb;">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div>
                                <strong>üìÑ Selected file:</strong> <span id="selectedFileName"></span>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger" onclick="clearSelectedFile()">
                                ‚ùå Clear
                            </button>
                        </div>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="convertDocument()">üöÄ Convert Document</button>
            </div>

            <div class="section">
                <button class="collapsible">üìã Debug Log</button>
                <div class="content">
                    <div id="debugLog" class="log">Ready to process your document...\n</div>
                    <button class="btn btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
                </div>
            </div>

            <div id="debugInfo" style="display: none;">
                <button class="collapsible">üîç Debug Information</button>
                <div class="content">
                    <div id="debugDetails" class="log"></div>
                </div>
            </div>

            <div id="results" style="display: none;">
                <div class="section">
                    <h3 style="color: var(--primary-color); margin-bottom: 1rem;">üìÅ Processing Results</h3>
                    <div id="fileList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variable to store the latest result for ZIP download
        let latestResult = null;

        function log(message) {
            const debugLog = document.getElementById('debugLog');
            const timestamp = UTILS.formatTimestamp();
            debugLog.textContent += `[${timestamp}] ${message}\n`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        function clearLog() {
            document.getElementById('debugLog').textContent = MESSAGES.LOG_CLEARED;
        }

        async function testWebhook() {
            const webhookUrl = document.getElementById('webhookUrl').value;
            const testResult = document.getElementById('testResult');

            if (!webhookUrl) {
                testResult.innerHTML = TEMPLATES.missingWebhookResponse();
                return;
            }

            log(`Testing webhook: ${webhookUrl}`);

            try {
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ test: true })
                });

                log(`Response status: ${response.status}`);
                log(`Response headers: ${JSON.stringify([...response.headers.entries()])}`);

                if (response.ok) {
                    testResult.innerHTML = TEMPLATES.successResponse();
                    log(MESSAGES.WEBHOOK_TEST_SUCCESS);
                } else {
                    const errorText = await response.text();
                    testResult.innerHTML = TEMPLATES.warningResponse(response.status);
                    log(`Response body: ${errorText}`);
                }

            } catch (error) {
                testResult.innerHTML = TEMPLATES.errorResponse(error.message);
                log(`${MESSAGES.WEBHOOK_TEST_FAILED}: ${error.message}`);

                if (error.message.includes('fetch')) {
                    log(MESSAGES.NETWORK_ERROR);
                    MESSAGES.CORS_SOLUTIONS.forEach(solution => log(solution));
                }
            }
        }

        // Validate file type when file is selected
        function validateFileType() {
            const fileInput = document.getElementById('document');
            const file = fileInput.files[0];

            if (file) {
                const fileName = file.name.toLowerCase();
                const allowedExtensions = ['.html', '.htm'];
                const isValidFile = allowedExtensions.some(ext => fileName.endsWith(ext));

                if (!isValidFile) {
                    log(`‚ùå Invalid file type: ${file.name}`);
                    log(`‚ö†Ô∏è Only HTML files (.html, .htm) are allowed`);
                    log(`üí° Please select an HTML file converted from your Word document`);

                    // Clear the file input
                    fileInput.value = '';

                    // Hide selected file display
                    hideSelectedFile();

                    // Show error message
                    alert(`Invalid file type!\n\nOnly HTML files (.html, .htm) are accepted.\n\nSelected file: ${file.name}\n\nPlease select an HTML file converted from your Word document.`);
                    return false;
                } else {
                    log(`‚úÖ Valid HTML file selected: ${file.name}`);
                    showSelectedFile(file);
                    return true;
                }
            }
            return true;
        }

        // Drag & Drop Functions
        function allowDrop(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];

                // Check file type
                const fileName = file.name.toLowerCase();
                const allowedExtensions = ['.html', '.htm'];
                const isValidFile = allowedExtensions.some(ext => fileName.endsWith(ext));

                if (!isValidFile) {
                    log(`‚ùå Invalid file type dropped: ${file.name}`);
                    log(`‚ö†Ô∏è Only HTML files (.html, .htm) are allowed`);
                    alert(`Invalid file type!\n\nOnly HTML files (.html, .htm) are accepted.\n\nDropped file: ${file.name}\n\nPlease drag an HTML file converted from your Word document.`);
                    return;
                }

                // Set file to hidden input
                const fileInput = document.getElementById('document');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;

                log(`‚úÖ Valid HTML file dropped: ${file.name}`);
                showSelectedFile(file);
            }
        }

        function triggerFileSelect() {
            document.getElementById('document').click();
        }

        function showSelectedFile(file) {
            const display = document.getElementById('selectedFileDisplay');
            const fileName = document.getElementById('selectedFileName');

            fileName.textContent = file.name;
            display.style.display = 'block';
        }

        function hideSelectedFile() {
            const display = document.getElementById('selectedFileDisplay');
            display.style.display = 'none';
        }

        function clearSelectedFile() {
            const fileInput = document.getElementById('document');
            fileInput.value = '';
            hideSelectedFile();
            log('üóëÔ∏è File selection cleared');
        }

        // Helper function to get line number from character position
        function getLineNumber(content, position) {
            const beforePosition = content.substring(0, position);
            return beforePosition.split('\n').length;
        }

        // Helper function to get context with line numbers and formatted code
        function getContextWithLineNumber(content, position, contextLines = 2) {
            const lines = content.split('\n');
            const targetLineIndex = getLineNumber(content, position) - 1; // Convert to 0-based index

            // Calculate the range of lines to show
            const startLine = Math.max(0, targetLineIndex - contextLines);
            const endLine = Math.min(lines.length - 1, targetLineIndex + contextLines);

            // Build the formatted context with line numbers on the same line
            let formattedContext = '';
            for (let i = startLine; i <= endLine; i++) {
                const lineNumber = (i + 1).toString().padStart(3, ' '); // 3-digit line numbers
                const indicator = i === targetLineIndex ? '‚Üí' : ' '; // Arrow points to the problem line
                const line = (lines[i] || '').replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML

                // Add special formatting for the problem line
                if (i === targetLineIndex) {
                    formattedContext += `<span style="color: #f56565; font-weight: bold;">${lineNumber}${indicator}</span> ${line}\n`;
                } else {
                    formattedContext += `<span style="color: #a0aec0;">${lineNumber}${indicator}</span> ${line}\n`;
                }
            }

            return {
                lineNumber: targetLineIndex + 1, // Convert back to 1-based
                context: content.substring(Math.max(0, position - 50), position + 100).replace(/\n/g, ' '), // Single line context for backwards compatibility
                formattedContext: formattedContext.trim() // Multi-line context with line numbers
            };
        }

        // Client-side style tag validation function
        function validateStyleTags(htmlContent) {
            const errors = [];
            const warnings = [];

            log('üîç Validating style tags in HTML content...');

            // Simple bracket validation
            const bracketErrors = [];

            // Find all bracket sequences that look like style tags
            const allBracketPatterns = /\[+(?:style:\s*[\w]+|\/style)\]+/gi;
            
            let match;
            while ((match = allBracketPatterns.exec(htmlContent)) !== null) {
                const found = match[0];
                const contextInfo = getContextWithLineNumber(htmlContent, match.index);
                let expectedFormat, errorType;
                
                // Determine what it should be and if it's correct
                if (found.includes('style:')) {
                    // Extract the style type (e.g., "read", "image", etc.)
                    const styleMatch = found.match(/style:\s*([\w]+)/i);
                    const styleType = styleMatch ? styleMatch[1] : 'xx';
                    expectedFormat = `[[style:${styleType}]]`;
                    
                    if (found !== expectedFormat) {
                        errorType = 'malformed_opening_tag';
                        bracketErrors.push({
                            type: errorType,
                            message: `Malformed opening tag: ${found} should be ${expectedFormat}`,
                            position: match.index,
                            line: contextInfo.lineNumber,
                            context: contextInfo.formattedContext,
                            found: found,
                            expected: expectedFormat
                        });
                        log(`‚ùå Malformed opening tag found: ${found} at line ${contextInfo.lineNumber}`);
                    }
                } else if (found.includes('/style')) {
                    expectedFormat = '[[/style]]';
                    
                    if (found !== expectedFormat) {
                        errorType = 'malformed_closing_tag';
                        bracketErrors.push({
                            type: errorType,
                            message: `Malformed closing tag: ${found} should be ${expectedFormat}`,
                            position: match.index,
                            line: contextInfo.lineNumber,
                            context: contextInfo.formattedContext,
                            found: found,
                            expected: expectedFormat
                        });
                        log(`‚ùå Malformed closing tag found: ${found} at line ${contextInfo.lineNumber}`);
                    }
                }
            }

            // Add bracket errors to the main errors array
            log(`üîç Found ${bracketErrors.length} bracket errors`);
            bracketErrors.forEach((error, index) => {
                log(`  ${index + 1}. [${error.type}] ${error.message} at line ${error.line}`);
                errors.push(error);
            });

            // Detailed opening/closing tag validation with stack-based matching
            const openingTags = [];
            const closingTags = [];
            
            // Find all opening tags with their positions and types
            const openingPattern = /\[\[style:\s*([\w]+)\]\]/gi;
            let openMatch;
            while ((openMatch = openingPattern.exec(htmlContent)) !== null) {
                const styleType = openMatch[1] ? openMatch[1].toLowerCase() : 'unknown';
                openingTags.push({
                    type: styleType,
                    fullMatch: openMatch[0],
                    position: openMatch.index,
                    line: getLineNumber(htmlContent, openMatch.index)
                });
                log(`‚úÖ Found opening: [[style:${styleType}]] at line ${getLineNumber(htmlContent, openMatch.index)}`);
            }
            
            // Find all closing tags with their positions
            const closingPattern = /\[\[\/style\]\]/gi;
            let closeMatch;
            while ((closeMatch = closingPattern.exec(htmlContent)) !== null) {
                closingTags.push({
                    fullMatch: closeMatch[0],
                    position: closeMatch.index,
                    line: getLineNumber(htmlContent, closeMatch.index)
                });
                log(`‚úÖ Found closing: [[/style]] at line ${getLineNumber(htmlContent, closeMatch.index)}`);
            }
            
            log(`üìä Style tag summary: ${openingTags.length} opening, ${closingTags.length} closing`);
            
            // Stack-based validation to find unmatched tags
            if (openingTags.length > 0 || closingTags.length > 0) {
                // Create combined array of all tags sorted by position
                const allTags = [];
                
                openingTags.forEach(tag => {
                    allTags.push({ ...tag, tagType: 'opening' });
                });
                
                closingTags.forEach(tag => {
                    allTags.push({ ...tag, tagType: 'closing', type: 'closing' });
                });
                
                // Sort by position
                allTags.sort((a, b) => a.position - b.position);
                
                // Process tags using stack-based validation
                const stack = [];
                const orphanedClosingTags = [];
                
                for (let i = 0; i < allTags.length; i++) {
                    const tag = allTags[i];
                    
                    if (tag.tagType === 'opening') {
                        stack.push(tag);
                        log(`üîç Found opening: [[style:${tag.type}]] at line ${tag.line} (position ${tag.position})`);
                    } else if (tag.tagType === 'closing') {
                        if (stack.length === 0) {
                            // Orphaned closing tag
                            const contextInfo = getContextWithLineNumber(htmlContent, tag.position);
                            orphanedClosingTags.push({
                                position: tag.position,
                                line: contextInfo.lineNumber,
                                context: contextInfo.formattedContext
                            });
                        } else {
                            // Match with most recent opening tag
                            const openingTag = stack.pop();
                            log(`‚úÖ Matched: [[style:${openingTag.type}]] (line ${openingTag.line}) with [[/style]] (line ${tag.line})`);
                        }
                    }
                }
                
                // Handle orphaned closing tags
                if (orphanedClosingTags.length > 0) {
                    const errorMsg = {
                        type: 'orphaned_closing',
                        message: `${orphanedClosingTags.length} orphaned closing tag${orphanedClosingTags.length > 1 ? 's' : ''} [[/style]] found with no matching opening tag${orphanedClosingTags.length > 1 ? 's' : ''}.`,
                        context: orphanedClosingTags.map(tag => 
                            `[[/style]] at line ${tag.line}\n${tag.context}`
                        ).join('\n\n')
                    };
                    errors.push(errorMsg);
                    log(`‚ùå ERROR: ${errorMsg.message}`);
                }
                
                // Handle unclosed opening tags (missing closing tags)
                if (stack.length > 0) {
                    // Create individual errors for each unclosed opening tag
                    stack.forEach(unclosedTag => {
                        const contextInfo = getContextWithLineNumber(htmlContent, unclosedTag.position);
                        const errorMsg = {
                            type: 'missing_closing',
                            message: `Opening tag [[style:${unclosedTag.type}]] at line ${contextInfo.lineNumber} is missing its closing tag [[/style]].`,
                            context: contextInfo.formattedContext
                        };
                        errors.push(errorMsg);
                        log(`‚ùå ERROR: Opening tag [[style:${unclosedTag.type}]] at line ${contextInfo.lineNumber} missing closing tag`);
                    });
                }
            }

            return { errors, warnings };
        }

        // Function to display style validation errors with formatted code
        function showStyleValidationErrors(errors, htmlContent) {
            // Create modal HTML
            const modalHtml = `
                <div id="errorModal" style="
                    position: fixed; 
                    top: 0; 
                    left: 0; 
                    width: 100%; 
                    height: 100%; 
                    background: rgba(0,0,0,0.7); 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    z-index: 10000;
                ">
                    <div style="
                        background: white; 
                        padding: 30px; 
                        border-radius: 10px; 
                        max-width: 80vw; 
                        max-height: 80vh; 
                        overflow-y: auto;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e74c3c; padding-bottom: 15px;">
                            <h2 style="margin: 0; color: #e74c3c; font-size: 1.5rem;">
                                ‚ùå Style Tag Validation Failed
                            </h2>
                            <button onclick="closeErrorModal()" style="
                                background: #e74c3c; 
                                color: white; 
                                border: none; 
                                padding: 8px 15px; 
                                border-radius: 5px; 
                                cursor: pointer; 
                                font-size: 1rem;
                            ">‚úñ Close</button>
                        </div>
                        <p style="margin-bottom: 20px; color: #333; font-size: 1.1rem;">
                            Found <strong>${errors.length}</strong> error${errors.length > 1 ? 's' : ''} in your HTML document:
                        </p>
                        <div id="errorList"></div>
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #17a2b8;">
                            <p style="margin: 0; color: #17a2b8; font-weight: bold;">üí° How to fix:</p>
                            <p style="margin: 5px 0 0 0; color: #333; font-size: 0.95rem;">
                                Edit your Word or HTML document to fix the issues shown above, then try uploading again. 
                            </p>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Populate error list
            const errorList = document.getElementById('errorList');
            errors.forEach((error, index) => {
                const errorDiv = document.createElement('div');
                errorDiv.style.marginBottom = '25px';
                errorDiv.style.padding = '15px';
                errorDiv.style.border = '1px solid #dc3545';
                errorDiv.style.borderRadius = '5px';
                errorDiv.style.backgroundColor = '#fff5f5';
                
                // Handle structured error object or legacy string format
                let errorMessage, codeContext;
                
                if (typeof error === 'object' && error.message) {
                    // New structured format
                    errorMessage = error.message;
                    codeContext = error.codeContext || error.context || '';
                } else {
                    // Legacy string format (fallback)
                    const parts = error.split('\n\nCode context:\n');
                    errorMessage = parts[0];
                    codeContext = parts[1] || '';
                }
                
                errorDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #dc3545; font-size: 1.1rem;">
                        Error ${index + 1}:
                    </h4>
                    <p style="margin: 0 0 15px 0; color: #333; font-size: 1rem; line-height: 1.4;">
                        ${errorMessage}
                    </p>
                    ${codeContext ? `
                        <div style="margin-top: 15px;">
                            <p style="margin: 0 0 8px 0; font-weight: bold; color: #495057; font-size: 0.95rem;">Code context:</p>
                            <pre style="
                                background: #2d3748; 
                                border: 1px solid #4a5568; 
                                border-radius: 6px; 
                                padding: 16px; 
                                margin: 0; 
                                font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; 
                                font-size: 0.85rem; 
                                line-height: 1.5; 
                                color: #e2e8f0;
                                overflow-x: auto;
                                white-space: pre;
                                text-align: left;
                                tab-size: 4;
                            ">${codeContext}</pre>
                        </div>
                    ` : ''}
                `;
                
                errorList.appendChild(errorDiv);
            });
            
            // Add global close function
            window.closeErrorModal = function() {
                const modal = document.getElementById('errorModal');
                if (modal) {
                    modal.remove();
                    delete window.closeErrorModal;
                }
            };
            
            // Close on background click
            document.getElementById('errorModal').addEventListener('click', function(e) {
                if (e.target.id === 'errorModal') {
                    closeErrorModal();
                }
            });
        }

        async function convertDocument() {
            const webhookUrl = document.getElementById('webhookUrl').value;
            const fileInput = document.getElementById('document');
            let learningOutcome = ''; // Default empty since input field was removed

            if (!webhookUrl || !fileInput.files[0]) {
                log(MESSAGES.MISSING_FIELDS);
                return;
            }

            // Validate file type before processing
            if (!validateFileType()) {
                return;
            }

            log(MESSAGES.CONVERSION_START);

            try {
                const file = fileInput.files[0];
                log(`üìÑ Reading file: ${file.name} (${file.size} bytes)`);

                const htmlContent = await file.text();
                log(`‚úÖ File content loaded (${htmlContent.length} characters)`);

                // CLIENT-SIDE STYLE TAG VALIDATION
                log('üîç Performing client-side style tag validation...');
                const validation = validateStyleTags(htmlContent);
                
                if (validation.errors.length > 0) {
                    log('‚ùå Style tag validation failed!');
                    
                    log(`Found ${validation.errors.length} total error${validation.errors.length > 1 ? 's' : ''}`);
                    validation.errors.forEach((error, index) => {
                        const errorType = error.type ? `[${error.type}]` : '';
                        log(`${index + 1}. ${errorType} ${error.message || error}`);
                    });
                    
                    // Show detailed error message to user with formatted code
                    showStyleValidationErrors(validation.errors, htmlContent);
                    
                    log('üí° Upload cancelled - please fix style tag issues and try again');
                    return; // Stop processing here
                }
                
                if (validation.warnings.length > 0) {
                    log(`‚ö†Ô∏è Style tag validation completed with ${validation.warnings.length} warning(s):`);
                    validation.warnings.forEach((warning, index) => {
                        log(`${index + 1}. ${warning}`);
                    });
                } else {
                    log('‚úÖ Style tag validation passed - no errors found');
                }

                // Auto-detect LO number from filename
                const loMatch = file.name.match(/LO(\d+)/i);
                if (loMatch) {
                    learningOutcome = loMatch[1].padStart(2, '0');
                    log(`üîç Auto-detected LO number from filename: ${learningOutcome}`);
                } else {
                    log(`üí° No LO number found in filename, workflow will use default`);
                }

                const payload = {
                    htmlContent: htmlContent,
                    fileName: file.name,
                    learningOutcome: learningOutcome
                };

                log('üì§ Sending to n8n...');
                log(`Payload size: ${JSON.stringify(payload).length} characters`);

                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });

                log(`üì• Response received: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                latestResult = result; // Store for download functionality

                log('‚úÖ Conversion successful!');
                log(`Response data: ${JSON.stringify(result, null, 2)}`);

                // Display results
                displayResults(result);

            } catch (error) {
                log(`‚ùå Conversion failed: ${error.message}`);
                console.error('Conversion error:', error);
            }
        }

        function displayResults(result) {
            const resultsDiv = document.getElementById('results');
            const fileListDiv = document.getElementById('fileList');
            
            resultsDiv.style.display = 'block';
            
            if (result.files && result.files.length > 0) {
                let html = '<h4>üìÅ Generated Files:</h4><ul>';
                result.files.forEach(file => {
                    html += `<li><strong>${file.fileName}</strong> (${file.size} bytes)</li>`;
                });
                html += '</ul>';
                
                html += '<button class="btn btn-success" onclick="downloadAllFiles()">üì¶ Download All Files</button>';
                
                fileListDiv.innerHTML = html;
            } else {
                fileListDiv.innerHTML = '<p>No files were generated.</p>';
            }
        }

        async function downloadAllFiles() {
            if (!latestResult || !latestResult.files || latestResult.files.length === 0) {
                log('‚ùå No files available for download');
                return;
            }

            log('üì¶ Preparing files for download...');
            
            // Create a simple download for each file
            latestResult.files.forEach(file => {
                const blob = new Blob([file.content], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                log(`üíæ Downloaded: ${file.fileName}`);
            });
        }

        // Load saved webhook URL on page load
        window.onload = function() {
            const savedUrl = localStorage.getItem('webhookUrl');
            if (savedUrl) {
                document.getElementById('webhookUrl').value = savedUrl;
            }
        };

        // Save webhook URL to localStorage
        document.getElementById('webhookUrl').addEventListener('change', function () {
            localStorage.setItem('webhookUrl', this.value);
        });

        // Validate file type immediately when file is selected
        document.getElementById('document').addEventListener('change', function () {
            validateFileType();
        });
    </script>
</body>

</html>