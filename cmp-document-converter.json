{
  "name": "CMP Document Converter (With Code Style + Auto-Indent + Copy Button + Conditional Prism Loading)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "cmp-document-upload",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "1",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        300
      ],
      "webhookId": "cmp-document-upload"
    },
    {
      "parameters": {
        "jsCode": "// Extract uploaded HTML document from webhook with basic validation\nconst input = $input.first().json;\n\nconsole.log('=== WEBHOOK DEBUG START ===');\nconsole.log('Full input keys:', Object.keys(input));\nconsole.log('Input type:', typeof input);\n\n// Extract HTML document data and metadata\nlet htmlContent, fileName, learningOutcome;\n\n// Check if data is nested in body\nif (input.body) {\n  console.log('Found input.body, checking contents...');\n  htmlContent = input.body.htmlContent;\n  fileName = input.body.fileName;\n  learningOutcome = input.body.learningOutcome;\n  console.log('From body - htmlContent length:', htmlContent ? htmlContent.length : 'null/undefined');\n  console.log('From body - fileName:', fileName);\n  console.log('From body - learningOutcome:', learningOutcome);\n} else {\n  console.log('No input.body found, checking top level...');\n  htmlContent = input.htmlContent;\n  fileName = input.fileName;\n  learningOutcome = input.learningOutcome;\n  console.log('From top level - htmlContent length:', htmlContent ? htmlContent.length : 'null/undefined');\n  console.log('From top level - fileName:', fileName);\n  console.log('From top level - learningOutcome:', learningOutcome);\n}\n\n// Basic validation\nif (!htmlContent) {\n  console.log('ERROR: No HTML content found!');\n  return {\n    success: false,\n    error: true,\n    message: 'No HTML document content found in upload',\n    files: [],\n    totalFiles: 0,\n    validation: {\n      status: 'error',\n      message: 'No HTML content provided',\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n\n// Set defaults\nfileName = fileName || 'uploaded-document.html';\nconsole.log('Final fileName:', fileName);\n\n// Enhanced LO detection\nif (!learningOutcome) {\n  console.log('No LO provided, attempting auto-detection...');\n  const contentLoMatch = htmlContent ? htmlContent.match(/<h1[^>]*>.*?LO\\s*(\\d+)/i) : null;\n  if (contentLoMatch) {\n    learningOutcome = contentLoMatch[1].padStart(2, '0');\n    console.log('Auto-detected LO from content:', learningOutcome);\n  } else {\n    const filenameLoMatch = fileName ? fileName.match(/LO(\\d+)/i) : null;\n    if (filenameLoMatch) {\n      learningOutcome = filenameLoMatch[1].padStart(2, '0');\n      console.log('Auto-detected LO from filename:', learningOutcome);\n    } else {\n      learningOutcome = '01';\n      console.log('Using default LO:', learningOutcome);\n    }\n  }\n} else {\n  learningOutcome = learningOutcome.padStart(2, '0');\n  console.log('Using provided LO:', learningOutcome);\n}\n\n// OPTIMIZATION: Check for [[style:code]] in input HTML to enable conditional Prism.js loading\nconst hasCodeBlocks = htmlContent && (\n  htmlContent.includes('[[style:code]]') || \n  htmlContent.includes('[[style: code]]') ||\n  /<p>\\s*\\[\\[style:\\s*code\\]\\]\\s*<\\/p>/i.test(htmlContent)\n);\n\nconsole.log('=== CODE DETECTION ===');\nconsole.log('Code blocks detected in input:', hasCodeBlocks ? 'YES - Prism.js will be loaded' : 'NO - Prism.js will NOT be loaded');\n\nconsole.log('=== FINAL EXTRACTION RESULTS ===');\nconsole.log('htmlContent found:', !!htmlContent);\nconsole.log('htmlContent length:', htmlContent ? htmlContent.length : 'N/A');\nconsole.log('fileName:', fileName);\nconsole.log('learningOutcome:', learningOutcome);\nconsole.log('hasCodeBlocks:', hasCodeBlocks);\nconsole.log('=== WEBHOOK DEBUG END ===');\n\nreturn {\n  htmlContent: htmlContent,\n  fileName: fileName,\n  learningOutcome: learningOutcome,\n  hasCodeBlocks: hasCodeBlocks\n};"
      },
      "id": "2",
      "name": "Process Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse HTML document with UNIVERSAL title transformation and comprehensive validation\nconst inputData = $input.first().json;\n\n// Validation helper functions\nconst validateParsingInput = (data) => {\n  if (!data || typeof data !== 'object') {\n    throw new Error('PARSE VALIDATION ERROR: Invalid input data structure - Expected object but received ' + typeof data);\n  }\n  \n  if (!data.htmlContent || typeof data.htmlContent !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Missing or invalid htmlContent - Expected string but received ' + typeof data.htmlContent);\n  }\n  \n  if (data.htmlContent.trim().length === 0) {\n    throw new Error('PARSE VALIDATION ERROR: HTML content is empty after trimming');\n  }\n  \n  if (!data.fileName || typeof data.fileName !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Missing or invalid fileName - Expected string but received ' + typeof data.fileName);\n  }\n  \n  if (!data.learningOutcome || typeof data.learningOutcome !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Missing or invalid learningOutcome - Expected string but received ' + typeof data.learningOutcome);\n  }\n  \n  return true;\n};\n\nconst validateH1Sections = (htmlContent) => {\n  const h1Count = (htmlContent.match(/<h1[^>]*>/gi) || []).length;\n  \n  if (h1Count === 0) {\n    throw new Error('PARSE VALIDATION ERROR: No H1 sections found in document. Document must contain at least one H1 heading for processing.');\n  }\n  \n  if (h1Count > 100) {\n    throw new Error('PARSE VALIDATION ERROR: Too many H1 sections found (' + h1Count + '). Maximum allowed is 100 sections.');\n  }\n  \n  console.log('✓ H1 sections validation passed:', h1Count, 'sections found');\n  return h1Count;\n};\n\nconst validateRequestMatches = (matches) => {\n  if (matches.length > 50) {\n    throw new Error('PARSE VALIDATION ERROR: Too many request sections found (' + matches.length + '). Maximum allowed is 50 request sections.');\n  }\n  \n  matches.forEach((match, index) => {\n    if (!match.fullMatch || typeof match.fullMatch !== 'string') {\n      throw new Error('PARSE VALIDATION ERROR: Invalid request match at index ' + index + ' - Missing fullMatch');\n    }\n    if (!match.requestContent || typeof match.requestContent !== 'string') {\n      throw new Error('PARSE VALIDATION ERROR: Invalid request match at index ' + index + ' - Missing requestContent');\n    }\n    if (typeof match.startIndex !== 'number' || typeof match.endIndex !== 'number') {\n      throw new Error('PARSE VALIDATION ERROR: Invalid request match at index ' + index + ' - Invalid index values');\n    }\n  });\n  \n  console.log('✓ Request matches validation passed:', matches.length, 'requests found');\n  return true;\n};\n\nconst validateSectionData = (section, index) => {\n  if (!section || typeof section !== 'object') {\n    throw new Error('PARSE VALIDATION ERROR: Invalid section data at index ' + index + ' - Expected object');\n  }\n  \n  if (!section.title || typeof section.title !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Missing or invalid title for section ' + index + ' - Expected non-empty string');\n  }\n  \n  if (section.title.length > 200) {\n    throw new Error('PARSE VALIDATION ERROR: Section title too long at index ' + index + ' (' + section.title.length + ' chars, max 200)');\n  }\n  \n  if (section.content && typeof section.content !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Invalid content type for section ' + index + ' - Expected string');\n  }\n  \n  if (!section.fileName || typeof section.fileName !== 'string') {\n    throw new Error('PARSE VALIDATION ERROR: Missing or invalid fileName for section ' + index);\n  }\n  \n  return true;\n};\n\ntry {\n  console.log('=== PARSE DOCUMENT SECTIONS DEBUG START ===');\n  \n  // Validate input data first\n  validateParsingInput(inputData);\n  console.log('✓ Input data validation passed');\n  \n  const htmlContent = inputData.htmlContent;\n  const fileName = inputData.fileName;\n  const learningOutcome = inputData.learningOutcome;\n  const hasCodeBlocks = inputData.hasCodeBlocks || false;\n  \n  console.log('Code blocks detected from Process Upload:', hasCodeBlocks ? 'YES' : 'NO');\n  \n  // Validate H1 sections exist\n  const h1Count = validateH1Sections(htmlContent);\n\n// Extract request sections first\nconst extractedRequestSections = [];\nlet cleanedHtmlContent = htmlContent;\n\n// First try P-wrapped pattern, then unwrapped pattern\nlet requestMatches = [];\nlet match;\n\n// Try P-wrapped pattern first\nconst wrappedPattern = /<p>\\s*\\[\\[style:\\s*requests?\\]\\]\\s*<\\/p>([\\s\\S]*?)<p>\\s*\\[\\[\\/style\\]\\]\\s*<\\/p>/gi;\nwhile ((match = wrappedPattern.exec(htmlContent)) !== null) {\n  requestMatches.push({\n    fullMatch: match[0],\n    requestContent: match[1].trim(),\n    startIndex: match.index,\n    endIndex: match.index + match[0].length\n  });\n}\n\n// Reset regex and try unwrapped pattern for any remaining\nconst unwrappedPattern = /\\[\\[style:\\s*requests?\\]\\]([\\s\\S]*?)\\[\\[\\/style\\]\\]/gi;\nlet tempContent = htmlContent;\n// Remove already found wrapped patterns to avoid duplicates\nrequestMatches.forEach(wrappedMatch => {\n  tempContent = tempContent.replace(wrappedMatch.fullMatch, '');\n});\nwhile ((match = unwrappedPattern.exec(tempContent)) !== null) {\n  // Adjust startIndex to account for original content\n  const adjustedStartIndex = htmlContent.indexOf(match[0]);\n  if (adjustedStartIndex !== -1) {\n    requestMatches.push({\n      fullMatch: match[0],\n      requestContent: match[1].trim(),\n      startIndex: adjustedStartIndex,\n      endIndex: adjustedStartIndex + match[0].length\n    });\n  }\n}\n\n// Sort matches by startIndex to maintain document order\nrequestMatches.sort((a, b) => a.startIndex - b.startIndex);\n\n// Validate request matches\nvalidateRequestMatches(requestMatches);\n\nrequestMatches.forEach((match, index) => {\n  const requestContent = match.requestContent;\n  let mediaType = 'Media';\n  \n  const mediaTypePatterns = [\n    { pattern: /graphics?\\s+request/i, type: 'Graphics' },\n    { pattern: /interactive?\\s+request/i, type: 'Interactive' },\n    { pattern: /video\\s+request/i, type: 'Video' },\n    { pattern: /audio\\s+request/i, type: 'Audio' },\n    { pattern: /image\\s+request/i, type: 'Image' }\n  ];\n  \n  for (const { pattern, type } of mediaTypePatterns) {\n    if (pattern.test(requestContent)) {\n      mediaType = type;\n      break;\n    }\n  }\n  \n  const requestInfo = {\n    mediaType: mediaType,\n    requestContent: requestContent,\n    fullMatch: match.fullMatch,\n    startIndex: match.startIndex,\n    endIndex: match.endIndex,\n    originalIndex: index\n  };\n  \n  extractedRequestSections.push(requestInfo);\n});\n\n// Remove request blocks and replace with placeholders\nfor (let i = requestMatches.length - 1; i >= 0; i--) {\n  const match = requestMatches[i];\n  const requestInfo = extractedRequestSections[i];\n  \n  const placeholder = `<div class=\"media-placeholder\" style=\"text-align: left;\">\n    <p><strong>[REQUEST]</strong></p>\n    <p>A ${requestInfo.mediaType.toLowerCase()} request has been extracted to <a href=\"LO${learningOutcome}_media_graphics_interactive_requests.html\" target=\"_blank\">the request tables file</a>.</p>\n    <p><strong>[WARNING]</strong> This placeholder should be replaced with the actual media content.</p>\n  </div>`;\n  \n  const before = cleanedHtmlContent.substring(0, match.startIndex);\n  const after = cleanedHtmlContent.substring(match.endIndex);\n  cleanedHtmlContent = before + placeholder + after;\n}\n\n// Parse H1 sections\nconsole.log('=== H1 PARSING DEBUG START ===');\nconsole.log('HTML content length for H1 parsing:', cleanedHtmlContent.length);\nconsole.log('First 500 chars of HTML:', cleanedHtmlContent.substring(0, 500));\n\nconst h1Regex = /<h1[^>]*>(.*?)<\\/h1>/gis;\nconst h1Matches = [];\nconst h1MatchesArray = Array.from(cleanedHtmlContent.matchAll(h1Regex));\n\nconsole.log('H1 regex matches found:', h1MatchesArray.length);\n\nfor (let i = 0; i < h1MatchesArray.length; i++) {\n  const match = h1MatchesArray[i];\n  const h1Info = {\n    fullMatch: match[0],\n    text: match[1].replace(/<[^>]*>/g, '').trim(),\n    index: match.index,\n    endIndex: match.index + match[0].length\n  };\n  \n  console.log(`H1 #${i + 1} found: \"${h1Info.text}\" at position ${h1Info.index}`);\n  \n  if (h1Info.text) {\n    h1Matches.push(h1Info);\n  } else {\n    console.log(`H1 #${i + 1} skipped - empty text after cleaning`);\n  }\n}\n\nconsole.log('Total valid H1 sections after filtering:', h1Matches.length);\nconsole.log('=== H1 PARSING DEBUG END ===');\n\n// Process sections with UNIVERSAL title transformation\nconst sections = [];\nconst debugInfo = [];\n\nfor (let i = 0; i < h1Matches.length; i++) {\n  const currentH1 = h1Matches[i];\n  const nextH1 = h1Matches[i + 1];\n  \n  const contentStart = currentH1.endIndex;\n  const contentEnd = nextH1 ? nextH1.index : cleanedHtmlContent.length;\n  let content = cleanedHtmlContent.substring(contentStart, contentEnd).trim();\n  \n  let title = currentH1.text.replace(/\\s+/g, ' ').trim();\n  let sectionType = 'content';\n  let fileName = '';\n  let patternMatched = null;\n  let sectionLO = learningOutcome;\n  let sectionLS = '00';\n  let sectionLA = '00';\n  \n  // UNIVERSAL X.Y.Z PATTERN MATCHING - handles all cases with optional . or : after Z\n  const universalMatch = title.match(/^(\\d+)\\.(\\d+)\\.(\\d+)[\\.:]?(?:\\s+(.*))?$/);\n  if (universalMatch) {\n    const [, lo, ls, la, titleText] = universalMatch;\n    sectionLO = lo.padStart(2, '0');\n    sectionLS = ls.padStart(2, '0');\n    sectionLA = la.padStart(2, '0');\n    \n    // Generate essence words (handle empty titles)\n    const essence = titleText ? titleText.toLowerCase()\n      .replace(/[^a-z0-9\\s]/g, '')\n      .replace(/\\s+/g, '_')\n      .substring(0, 30) : 'content';\n    \n    // Determine section type and special LO intro case\n    if (ls === '0' && la === '0') {\n      sectionType = 'learning-outcome';\n      // Check for LO intro pattern: X.0.0 with optional punctuation/space and no title text\n      if (!titleText || titleText.trim() === '') {\n        fileName = `${sectionLO}_00_00_intro.html`;\n        patternMatched = 'X.0.0 LO Intro Pattern';\n      } else {\n        fileName = `${sectionLO}_${sectionLS}_${sectionLA}_${essence}.html`;\n        patternMatched = 'Universal X.Y.Z Pattern';\n      }\n    } else if (la === '0') {\n      sectionType = 'learning-step';\n      fileName = `${sectionLO}_${sectionLS}_${sectionLA}_${essence}.html`;\n      patternMatched = 'Universal X.Y.Z Pattern';\n    } else {\n      sectionType = 'learning-activity';\n      fileName = `${sectionLO}_${sectionLS}_${sectionLA}_${essence}.html`;\n      patternMatched = 'Universal X.Y.Z Pattern';\n    }\n    \n    // UNIVERSAL TITLE TRANSFORMATION for HTML display\n    if (ls === '0' && la === '0') {\n      // X.0.0 → X. + rest of title\n      title = titleText ? `${lo}. ${titleText}` : `${lo}.`;\n    } else if (la === '0') {\n      // X.Y.0 → Step Y: + rest of title\n      title = titleText ? `Step ${ls}: ${titleText}` : `Step ${ls}:`;\n    } else {\n      // X.Y.Z → Y.Z + rest of title\n      title = titleText ? `${ls}.${la} ${titleText}` : `${ls}.${la}`;\n    }\n  }\n  // Legacy patterns for backward compatibility\n  else if (title.match(/^LO\\s*(\\d+)?\\s*Summary:?/i)) {\n    // Handle both \"LO Summary\" and \"LO1 Summary\" or \"LO 1 Summary\" formats\n    const loSummaryMatch = title.match(/^LO\\s*(\\d+)?\\s*Summary:?/i);\n    sectionType = 'learning-outcome';\n    \n    // If there's a number in the title, use it; otherwise use current learningOutcome\n    if (loSummaryMatch[1]) {\n      sectionLO = loSummaryMatch[1].padStart(2, '0');\n    }\n    // sectionLO already set to learningOutcome if no number found\n    \n    fileName = `${sectionLO}_00_00_summary.html`;\n    patternMatched = 'LO Summary (Legacy)';\n  }\n  else if (title.match(/^LO\\s*(\\d+)(?!\\s+(Step|Summary))/i)) {\n    const loIntroMatch = title.match(/^LO\\s*(\\d+)/i);\n    sectionLO = loIntroMatch[1].padStart(2, '0');\n    sectionType = 'learning-outcome';\n    fileName = `${sectionLO}_00_00_intro.html`;\n    patternMatched = 'LO Intro (Legacy)';\n  }\n  \n  // Fallback\n  if (!fileName) {\n    const sequentialNumber = (i + 1).toString().padStart(2, '0');\n    const essence = title.toLowerCase()\n      .replace(/[^a-z0-9\\s]/g, '')\n      .replace(/\\s+/g, '_')\n      .substring(0, 30);\n    fileName = `${sectionLO}_${sequentialNumber}_00_${essence}.html`;\n    patternMatched = 'Fallback Sequential';\n  }\n  \n  debugInfo.push({\n    title: title,\n    fileName: fileName,\n    patternMatched: patternMatched\n  });\n  \n  const section = {\n    id: `section-${i + 1}`,\n    title: title,\n    content: content,\n    type: sectionType,\n    order: i + 1,\n    fileName: fileName,\n    sectionLO: sectionLO,\n    sectionLS: sectionLS,\n    sectionLA: sectionLA\n  };\n  \n  // Validate section before adding\n  validateSectionData(section, i);\n  sections.push(section);\n}\n\n// Final validation of processed sections\nif (sections.length === 0) {\n  throw new Error('PARSE VALIDATION ERROR: No valid sections were created from the document');\n}\n\nconsole.log('✓ All sections validated successfully:', sections.length, 'sections created');\n\n// Associate requests with sections\nextractedRequestSections.forEach((request, index) => {\n  const sectionIndex = Math.min(index, sections.length - 1);\n  const associatedSection = sections[sectionIndex];\n  \n  const sectionIdentifier = `LO${associatedSection.sectionLO}_LS${associatedSection.sectionLS}_LA${associatedSection.sectionLA}_${request.mediaType.toLowerCase()}_${request.originalIndex + 1}`;\n  \n  request.sectionIdentifier = sectionIdentifier;\n  request.sectionLO = associatedSection.sectionLO;\n  request.sectionLS = associatedSection.sectionLS;\n  request.sectionLA = associatedSection.sectionLA;\n  request.sectionTitle = associatedSection.title;\n});\n\nconsole.log('=== PARSE DOCUMENT SECTIONS DEBUG END ===');\n\nreturn {\n  sections: sections,\n  debugInfo: debugInfo,\n  extractedRequestSections: extractedRequestSections,\n  hasCodeBlocks: hasCodeBlocks,\n  metadata: {\n    originalFileName: fileName,\n    learningOutcome: learningOutcome,\n    totalSections: sections.length,\n    totalExtractedRequests: extractedRequestSections.length,\n    processingDate: new Date().toISOString(),\n    h1Count: h1Count,\n    hasCodeBlocks: hasCodeBlocks\n  },\n  validation: {\n    status: 'success',\n    message: 'Document parsing completed successfully',\n    sectionsProcessed: sections.length,\n    requestsExtracted: extractedRequestSections.length,\n    timestamp: new Date().toISOString()\n  }\n};\n\n} catch (error) {\n  console.log('ERROR in Parse Document Sections:', error.message);\n  \n  // Enhanced error reporting for HTML debug display\n  const errorDetails = {\n    status: 'error',\n    message: error.message,\n    errorType: 'ParsingError',\n    timestamp: new Date().toISOString(),\n    node: 'Parse Document Sections (Node 3)',\n    inputValidation: {\n      hasValidInput: !!inputData,\n      hasHtmlContent: !!(inputData?.htmlContent),\n      contentLength: inputData?.htmlContent?.length || 0,\n      hasFileName: !!(inputData?.fileName),\n      hasLearningOutcome: !!(inputData?.learningOutcome)\n    },\n    troubleshooting: [\n      'Check if HTML contains valid H1 headings',\n      'Verify document structure and formatting',\n      'Ensure H1 sections are properly formatted',\n      'Check for special characters in titles',\n      'Verify request sections use correct [[style:request]] format'\n    ]\n  };\n  \n  console.log('Parse error details:', JSON.stringify(errorDetails, null, 2));\n  \n  // Return error information instead of throwing, so it can be displayed in HTML debug\n  return {\n    sections: [],\n    debugInfo: [],\n    extractedRequestSections: [],\n    hasCodeBlocks: false,\n    metadata: {\n      originalFileName: inputData?.fileName || 'unknown',\n      learningOutcome: inputData?.learningOutcome || '01',\n      totalSections: 0,\n      totalExtractedRequests: 0,\n      processingDate: new Date().toISOString(),\n      h1Count: 0,\n      hasCodeBlocks: false\n    },\n    validation: {\n      status: 'error',\n      message: error.message,\n      errorDetails: errorDetails,\n      timestamp: new Date().toISOString()\n    },\n    error: true,\n    errorInfo: errorDetails\n  };\n}"
      },
      "id": "3",
      "name": "Parse Document Sections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate HTML files with CONDITIONAL Prism.js loading, +2px margin-top, and optimized performance\nconst items = $input.all();\nconst data = items[0].json;\n\ntry {\n  console.log('=== GENERATE HTML FILES DEBUG START ===');\n  \n  const sections = data.sections;\n  const metadata = data.metadata;\n  const extractedRequestSections = data.extractedRequestSections || [];\n  const globalHasCodeBlocks = data.hasCodeBlocks || metadata.hasCodeBlocks || false;\n\n  const originalFileName = metadata.originalFileName || 'unknown-document';\n  const folderName = originalFileName.replace(/\\.[^/.]+$/, '');\n  const folderPath = `./${folderName}`;\n\n  // Track if any section contains code for conditional library loading\n  let containsCodeBlocks = globalHasCodeBlocks;\n  let globalCodeCounter = 0; // Global counter for unique code block IDs\n\n  console.log('=== CONDITIONAL PRISM LOADING DEBUG ===');\n  console.log('Global code blocks detected:', globalHasCodeBlocks ? 'YES' : 'NO');\n  console.log('Prism.js will be loaded:', containsCodeBlocks ? 'YES' : 'NO');\n\n  // OPTIMIZED HTML template with CONDITIONAL Prism.js loading and +2px margin-top\n  const htmlTemplate = (title, content, hasCodeBlocks = false) => {\n    // CONDITIONAL: Only include Prism.js if code blocks are detected\n    const prismIncludes = hasCodeBlocks ? `\n    <!-- Prism.js for syntax highlighting - CONDITIONALLY LOADED -->\n    <link href=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css\" rel=\"stylesheet\" />\n    <link href=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css\" rel=\"stylesheet\" />\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js\"></script>\n    <script>\n        // Enhanced initialization with +2px margin-top and all optimizations\n        document.addEventListener('DOMContentLoaded', function() {\n            // Ensure all code blocks are properly processed\n            setTimeout(function() {\n                // First, highlight all code blocks\n                Prism.highlightAll();\n                \n                // Then ensure line numbers are properly recalculated\n                setTimeout(function() {\n                    if (Prism.plugins && Prism.plugins.lineNumbers) {\n                        document.querySelectorAll('pre.line-numbers').forEach(function(pre) {\n                            // Force line number recalculation\n                            Prism.plugins.lineNumbers.resize(pre);\n                            \n                            // Apply additional fixes for consistent spacing and alignment\n                            const lineNumbersContainer = pre.querySelector('.line-numbers-rows');\n                            if (lineNumbersContainer) {\n                                // +2px margin-top as requested\n                                lineNumbersContainer.style.paddingTop = '2px';\n                                lineNumbersContainer.style.lineHeight = '1.5';\n                                lineNumbersContainer.style.fontSize = '14px';\n                                lineNumbersContainer.style.fontFamily = \"'Consolas', 'Monaco', 'Courier New', monospace\";\n                            }\n                        });\n                    }\n                    \n                    // Final check to ensure all lines are numbered\n                    document.querySelectorAll('pre.line-numbers code').forEach(function(codeElement) {\n                        const pre = codeElement.closest('pre');\n                        const lines = codeElement.textContent.split('\\n');\n                        const lineNumbersContainer = pre.querySelector('.line-numbers-rows');\n                        \n                        if (lineNumbersContainer) {\n                            const spans = lineNumbersContainer.querySelectorAll('span');\n                            // Ensure we have a span for every line, including empty ones\n                            if (spans.length < lines.length) {\n                                for (let i = spans.length; i < lines.length; i++) {\n                                    const span = document.createElement('span');\n                                    lineNumbersContainer.appendChild(span);\n                                }\n                            }\n                        }\n                    });\n                }, 200);\n            }, 100);\n        });\n    </script>\n    <style>\n        /* CONDITIONAL CODE STYLES - Only loaded when [[style:code]] is present */\n        .code-block {\n            margin: 20px auto;\n            border-radius: 8px;\n            overflow: hidden;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n            position: relative;\n            /* Code blocks are narrower (80%) and centered */\n            max-width: 80%;\n            width: 80%;\n        }\n        \n        .code-block pre {\n            margin: 0;\n            padding: 0;\n            background: #f8f8f2;\n            overflow-x: auto;\n            /* Consistent font for both line numbers and code */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        .code-block code {\n            /* Consistent font and spacing between line numbers and code */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        /* Enhanced line numbers styling with +2px margin-top */\n        .line-numbers .line-numbers-rows {\n            /* UPDATED: +2px margin-top as requested */\n            margin-top: 2px !important;\n            border-right: 1px solid #d1d5da;\n            padding-right: 10px;\n            user-select: none;\n            pointer-events: none;\n            /* Same font and spacing as code */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        .line-numbers .line-numbers-rows > span {\n            pointer-events: none;\n            display: block;\n            counter-increment: linenumber;\n            /* Consistent spacing and font with code content */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        .line-numbers .line-numbers-rows > span::before {\n            content: counter(linenumber);\n            color: #999;\n            display: block;\n            padding-right: 0.8em;\n            text-align: right;\n            /* Exact same font and sizing as code */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        pre[class*=\"language-\"].line-numbers {\n            position: relative;\n            padding-left: 3.8em;\n            counter-reset: linenumber;\n            /* Proper font consistency and line numbering */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        pre[class*=\"language-\"].line-numbers > code {\n            position: relative;\n            white-space: pre;\n            /* Consistent font and ensure all lines are processed */\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;\n            font-size: 14px !important;\n            line-height: 1.5 !important;\n        }\n        \n        /* Copy button styling */\n        .copy-button {\n            position: absolute;\n            top: 8px;\n            right: 8px;\n            background: #007acc;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            padding: 6px 12px;\n            font-size: 12px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-family: Arial, sans-serif;\n            z-index: 10;\n        }\n        .copy-button:hover {\n            background: #005a9e;\n            transform: translateY(-1px);\n        }\n        .copy-button:active {\n            transform: translateY(0);\n        }\n        .copy-button.copied {\n            background: #28a745;\n        }\n        \n        /* Responsive design for code blocks */\n        @media (max-width: 768px) {\n            .code-block {\n                max-width: 95%;\n                width: 95%;\n            }\n        }\n    </style>\n    <script>\n        // Copy functionality for code blocks\n        function copyCodeToClipboard(button, codeId) {\n            const codeElement = document.getElementById(codeId);\n            const codeText = codeElement.textContent || codeElement.innerText;\n            \n            // Use modern clipboard API if available\n            if (navigator.clipboard && window.isSecureContext) {\n                navigator.clipboard.writeText(codeText).then(function() {\n                    showCopyFeedback(button);\n                }).catch(function(err) {\n                    fallbackCopyTextToClipboard(codeText, button);\n                });\n            } else {\n                fallbackCopyTextToClipboard(codeText, button);\n            }\n        }\n        \n        function fallbackCopyTextToClipboard(text, button) {\n            const textArea = document.createElement('textarea');\n            textArea.value = text;\n            textArea.style.position = 'fixed';\n            textArea.style.left = '-999999px';\n            textArea.style.top = '-999999px';\n            document.body.appendChild(textArea);\n            textArea.focus();\n            textArea.select();\n            \n            try {\n                const successful = document.execCommand('copy');\n                if (successful) {\n                    showCopyFeedback(button);\n                }\n            } catch (err) {\n                console.error('Copy failed:', err);\n            }\n            \n            document.body.removeChild(textArea);\n        }\n        \n        function showCopyFeedback(button) {\n            const originalText = button.textContent;\n            button.textContent = 'Copied!';\n            button.classList.add('copied');\n            \n            setTimeout(function() {\n                button.textContent = originalText;\n                button.classList.remove('copied');\n            }, 2000);\n        }\n    </script>` : '';\n    \n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${title}</title>\n    <link rel=\"stylesheet\" href=\"https://online.saskpolytech.ca/shared/sp-template/styles/SP-Global-2015.css\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://online.saskpolytech.ca/shared/sp-template/styles/SP-bootstrap-grid.css\">\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js\"></script>\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js\"></script>\n    <script src=\"https://online.saskpolytech.ca/shared/sp-template/scripts/jquery.ui.touch-punch.min.js\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://online.saskpolytech.ca/shared/sp-template/styles/jquery-ui.min.css\">\n    <script src=\"https://online.saskpolytech.ca/shared/sp-template/scripts/snippets/accordion.js\"></script>\n    <script src=\"https://online.saskpolytech.ca/shared/sp-template/scripts/snippets/show_more.js\"></script>${prismIncludes}\n    <style>\n        .media-placeholder {\n            background-color: #e2e3e5;\n            border: 2px dashed #6c757d;\n            padding: 20px;\n            text-align: center;\n            margin: 20px auto;\n            color: #495057;\n            border-radius: 5px;\n            width: 50%;\n            max-width: 600px;\n        }\n    </style>\n</head>\n<body>\n    <main class=\"course-content\">\n        <h1>${title}</h1>\n        ${content}\n    </main>\n</body>\n</html>`;\n  };\n\n  const generatedFiles = [];\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i];\n    \n    if (!section.title) {\n      continue;\n    }\n    \n    let processedContent = section.content || '';\n    let sectionHasCode = false; // Track if THIS section has code blocks\n    \n    // Function to decode HTML entities\n    const decodeHtmlEntities = (text) => {\n      const entities = {\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&quot;': '\"',\n        '&apos;': \"'\",\n        '&nbsp;': ' '\n      };\n      return text.replace(/&[#\\w]+;/g, (entity) => {\n        return entities[entity] || entity;\n      });\n    };\n    \n    // Decode HTML entities in the content\n    processedContent = decodeHtmlEntities(processedContent);\n    \n    // Apply activity styling with enhanced CODE SYNTAX HIGHLIGHTING\n    const applyActivityStyling = (content) => {\n      let result = content;\n      \n      // Handle all style tags\n      const patterns = [\n        {\n          name: 'P-wrapped style tags',\n          regex: /<p>\\s*\\[\\[style:\\s*(?!requests?)([\\w]+)\\]\\]\\s*<\\/p>([\\s\\S]*?)<p>\\s*\\[\\[\\/style\\]\\]\\s*<\\/p>/gi\n        },\n        {\n          name: 'Unwrapped style tags',\n          regex: /\\[\\[style:\\s*(?!requests?)([\\w]+)\\]\\]([\\s\\S]*?)\\[\\[\\/style\\]\\]/gi\n        }\n      ];\n      \n      patterns.forEach((pattern) => {\n        result = result.replace(pattern.regex, (match, styleType, innerContent) => {\n          const cleanContent = innerContent ? decodeHtmlEntities(innerContent.trim()) : '';\n          \n          switch(styleType.toLowerCase()) {\n            case 'read':\n              return `<div class=\"activity sand\">\n<h2>Read</h2>\n${cleanContent}\n</div>`;\n            \n            case 'watch':\n              return `<div class=\"activity sand\">\n<h2>Watch</h2>\n${cleanContent}\n</div>`;\n            \n            case 'activity':\n              return `<div class=\"activity sand\">\n<h2>Activity</h2>\n${cleanContent}\n</div>`;\n            \n            case 'discussion':\n              return `<div class=\"activity green\">\n<h2>Discussion</h2>\n${cleanContent}\n</div>`;\n            \n            case 'post':\n              return `<div class=\"activity green\">\n<h2>Post</h2>\n${cleanContent}\n</div>`;\n            \n            case 'assignment':\n              return `<div class=\"activity sand\">\n<h2>Assignment</h2>\n${cleanContent}\n</div>`;\n            \n            case 'reference':\n              const referenceContent = cleanContent.replace(/<em>/gi, '<cite>').replace(/<\\/em>/gi, '</cite>');\n              return `<div class=\"msgHead accor_ref\" style=\"clear: both;\">\n<h2>Reference(s)</h2>\n</div>\n<div class=\"msgBody accor_ref_body\">\n${referenceContent}\n</div>`;\n            \n            case 'image':\n              // Extract image src from img tag\n              const imgMatch = cleanContent.match(/<img[^>]*src=\"([^\"]*)\"/i);\n              const imgSrc = imgMatch ? imgMatch[1] : '';\n              \n              // Extract Citation and Caption from paragraph content\n              let citation = '';\n              let caption = '';\n              \n              // Look for Citation: pattern (case insensitive)\n              const citationMatch = cleanContent.match(/Citation:\\s*([^\\n<]+)/i);\n              if (citationMatch) {\n                citation = citationMatch[1].trim();\n              }\n              \n              // Look for Caption: pattern (case insensitive)  \n              const captionMatch = cleanContent.match(/Caption:\\s*([^\\n<]+)/i);\n              if (captionMatch) {\n                caption = captionMatch[1].trim();\n              }\n              \n              // Build the figure element\n              return `<figure class=\"add-citation\" data-citation=\"${citation}\">\n<img src=\"${imgSrc}\" alt=\"${caption}\"/>\n<figcaption>${caption}</figcaption>\n</figure>`;\n            \n            case 'transcript':\n            case 'transcripts':\n            case 'caption':\n            case 'captions':\n              // Extract button text from first p tag (handle any formatting)\n              const firstPMatch = cleanContent.match(/<p[^>]*>([^<]*(?:<[^>]*>[^<]*)*?)<\\/p>/i);\n              const buttonText = firstPMatch ? firstPMatch[1].replace(/<[^>]*>/g, '').trim() : 'Text Version of the Visual';\n              const transcriptContent = cleanContent.replace(/<p[^>]*>[^<]*(?:<[^>]*>[^<]*)*?<\\/p>\\s*/, '').trim();\n              return `<p><button class=\"moreClick\">${buttonText}</button></p>\n<div class=\"moreShow\">\n${transcriptContent}\n</div>`;\n            \n            case 'note':\n              return `<div class=\"media-placeholder\" style=\"text-align: left;\">\n<p><strong>[CMP NOTES]</strong></p>\n${cleanContent}\n</div>`;\n            \n            case 'imageleft':\n            case 'imageright':\n              const floatClass = styleType.toLowerCase() === 'imageleft' ? 'leftfloat' : 'rightfloat';\n              \n              // Extract image src from img tag\n              const floatImgMatch = cleanContent.match(/<img[^>]*src=\"([^\"]*)\"/i);\n              const floatImgSrc = floatImgMatch ? floatImgMatch[1] : '';\n              \n              // Extract Citation and Caption from paragraph content\n              let floatCitation = '';\n              let floatCaption = '';\n              \n              // Look for Citation: pattern (case insensitive)\n              const floatCitationMatch = cleanContent.match(/Citation:\\s*([^\\n<]+)/i);\n              if (floatCitationMatch) {\n                floatCitation = floatCitationMatch[1].trim();\n              }\n              \n              // Look for Caption: pattern (case insensitive)  \n              const floatCaptionMatch = cleanContent.match(/Caption:\\s*([^\\n<]+)/i);\n              if (floatCaptionMatch) {\n                floatCaption = floatCaptionMatch[1].trim();\n              }\n              \n              // Build the figure element\n              return `<figure class=\"${floatClass} add-citation\" data-citation=\"${floatCitation}\">\n<img src=\"${floatImgSrc}\" alt=\"${floatCaption}\"/>\n<figcaption>${floatCaption}</figcaption>\n</figure>`;\n            \n            case 'standout':\n            case 'callout':\n            case 'instruction':\n              // Clean content by removing id attributes from h2 tags\n              const standoutContent = cleanContent.replace(/<h2[^>]*id=\"[^\"]*\"([^>]*)>/gi, '<h2$1>');\n              return `<div class=\"example-standout box-shadow calc-example-standout\">\n${standoutContent}\n</div>`;\n            \n            case 'calloutright':\n            case 'standoutright':\n            case 'exampleright':\n              return `<aside class=\"blue side\">\n<h2>Note:</h2>\n${cleanContent}\n</aside>`;\n            \n            case 'code':\n              // ENHANCED: Auto-detect programming language with all optimizations\n              const detectLanguage = (codeContent) => {\n                const content = codeContent.toLowerCase();\n                \n                // Language patterns for auto-detection\n                if (content.includes('function') && content.includes('{') && (content.includes('const') || content.includes('let') || content.includes('var'))) {\n                  return 'javascript';\n                }\n                if (content.includes('def ') && content.includes(':')) {\n                  return 'python';\n                }\n                if (content.includes('<?php') || content.includes('<?=')) {\n                  return 'php';\n                }\n                if (content.includes('#include') || content.includes('int main') || content.includes('cout <<')) {\n                  return 'cpp';\n                }\n                if (content.includes('public class') || content.includes('System.out.println') || content.includes('public static void main')) {\n                  return 'java';\n                }\n                if (content.includes('SELECT') || content.includes('FROM') || content.includes('WHERE') || content.includes('INSERT')) {\n                  return 'sql';\n                }\n                if (content.includes('<html') || content.includes('<div') || content.includes('<head')) {\n                  return 'html';\n                }\n                if (content.includes('.class') || content.includes('#id') || content.includes('@media')) {\n                  return 'css';\n                }\n                if (content.includes('#!/bin/bash') || content.includes('chmod') || content.includes('ls -')) {\n                  return 'bash';\n                }\n                if (content.includes('import ') && content.includes('from ')) {\n                  return 'python';\n                }\n                if (content.includes('package ') && content.includes('import ')) {\n                  return 'go';\n                }\n                if (content.includes('fn ') && content.includes('->')) {\n                  return 'rust';\n                }\n                if (content.includes('using System') || content.includes('Console.WriteLine')) {\n                  return 'csharp';\n                }\n                \n                return 'text'; // fallback to plain text\n              };\n              \n              // ENHANCED: Auto-indentation function with all optimizations\n              const autoIndent = (code, language) => {\n                if (!code || typeof code !== 'string') return code;\n                \n                // Split into lines - preserve ALL lines for accurate line numbering\n                let lines = code.split('\\n');\n                \n                // Only remove leading empty lines, preserve trailing for accurate count\n                while (lines.length > 0 && lines[0].trim() === '') {\n                  lines.shift();\n                }\n                \n                if (lines.length === 0) return code;\n                \n                // Find the minimum indentation (excluding empty lines)\n                let minIndent = Infinity;\n                lines.forEach(line => {\n                  if (line.trim() !== '') {\n                    const leadingSpaces = line.match(/^\\s*/)[0].length;\n                    minIndent = Math.min(minIndent, leadingSpaces);\n                  }\n                });\n                \n                // Normalize indentation (remove common leading whitespace)\n                if (minIndent > 0 && minIndent !== Infinity) {\n                  lines = lines.map(line => {\n                    if (line.trim() === '') return '';\n                    return line.substring(minIndent);\n                  });\n                }\n                \n                // Language-specific auto-indentation with 2-space indents\n                const indentSize = 2;\n                let indentLevel = 0;\n                const indentedLines = [];\n                \n                for (let i = 0; i < lines.length; i++) {\n                  const line = lines[i];\n                  const trimmedLine = line.trim();\n                  \n                  if (trimmedLine === '') {\n                    indentedLines.push('');\n                    continue;\n                  }\n                  \n                  // Language-specific indentation logic\n                  if (language === 'javascript' || language === 'java' || language === 'cpp' || language === 'csharp' || language === 'css') {\n                    // Decrease indent for closing braces\n                    if (trimmedLine.startsWith('}') || trimmedLine.startsWith(']') || trimmedLine.startsWith(')')) {\n                      indentLevel = Math.max(0, indentLevel - 1);\n                    }\n                    \n                    // Apply current indentation\n                    indentedLines.push(' '.repeat(indentLevel * indentSize) + trimmedLine);\n                    \n                    // Increase indent for opening braces\n                    if (trimmedLine.endsWith('{') || trimmedLine.endsWith('[') || trimmedLine.endsWith('(')) {\n                      indentLevel++;\n                    }\n                  }\n                  else if (language === 'python') {\n                    // Python uses colons to indicate new blocks\n                    if (i > 0 && lines[i - 1].trim().endsWith(':')) {\n                      indentLevel++;\n                    }\n                    \n                    // Decrease indent for dedented lines (approximate)\n                    const currentLineIndent = line.match(/^\\s*/)[0].length;\n                    if (i > 0) {\n                      const prevLineIndent = lines[i - 1].match(/^\\s*/)[0].length;\n                      if (currentLineIndent < prevLineIndent && trimmedLine !== '') {\n                        indentLevel = Math.max(0, Math.floor(currentLineIndent / indentSize));\n                      }\n                    }\n                    \n                    indentedLines.push(' '.repeat(indentLevel * indentSize) + trimmedLine);\n                  }\n                  else if (language === 'html') {\n                    // HTML tag-based indentation\n                    const openTags = (trimmedLine.match(/<[^/][^>]*>/g) || []).length;\n                    const closeTags = (trimmedLine.match(/<\\/[^>]*>/g) || []).length;\n                    const selfClosing = (trimmedLine.match(/<[^>]*\\/>/g) || []).length;\n                    \n                    // Decrease indent for closing tags at start of line\n                    if (trimmedLine.startsWith('</')) {\n                      indentLevel = Math.max(0, indentLevel - 1);\n                    }\n                    \n                    indentedLines.push(' '.repeat(indentLevel * indentSize) + trimmedLine);\n                    \n                    // Increase indent for opening tags (excluding self-closing)\n                    indentLevel += (openTags - closeTags - selfClosing);\n                    indentLevel = Math.max(0, indentLevel);\n                  }\n                  else {\n                    // Default: maintain relative indentation but normalize to 2-space\n                    const originalIndent = line.length - line.trimLeft().length;\n                    const normalizedIndent = Math.floor(originalIndent / 2) * indentSize;\n                    indentedLines.push(' '.repeat(normalizedIndent) + trimmedLine);\n                  }\n                }\n                \n                // Ensure proper ending to maintain line count accuracy\n                const finalCode = indentedLines.join('\\n');\n                return finalCode;\n              };\n              \n              // Extract code content from pre/code tags or plain text\n              let codeContent = cleanContent;\n              const preMatch = cleanContent.match(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/i);\n              const codeMatch = cleanContent.match(/<code[^>]*>([\\s\\S]*?)<\\/code>/i);\n              \n              if (preMatch) {\n                codeContent = preMatch[1];\n              } else if (codeMatch) {\n                codeContent = codeMatch[1];\n              }\n              \n              // Clean HTML entities and tags from code content\n              codeContent = codeContent\n                .replace(/&lt;/g, '<')\n                .replace(/&gt;/g, '>')\n                .replace(/&amp;/g, '&')\n                .replace(/&quot;/g, '\"')\n                .replace(/<[^>]*>/g, '');\n              \n              const detectedLanguage = detectLanguage(codeContent);\n              \n              // Apply auto-indentation\n              const indentedCode = autoIndent(codeContent, detectedLanguage);\n              \n              // Ensure code preserves all lines for proper line numbering\n              const finalCodeForDisplay = indentedCode;\n              \n              // Generate unique ID for this code block\n              globalCodeCounter++;\n              const codeId = `code-block-${globalCodeCounter}`;\n              \n              // Mark that this section contains code and update global flag\n              sectionHasCode = true;\n\n              \n              console.log(`Code block ${globalCodeCounter} detected in section ${i + 1}: ${section.title}`);\n              \n              return `<div class=\"code-block\">\n<button class=\"copy-button\" onclick=\"copyCodeToClipboard(this, '${codeId}')\">Copy</button>\n<pre class=\"line-numbers\"><code id=\"${codeId}\" class=\"language-${detectedLanguage}\">${finalCodeForDisplay.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>\n</div>`;\n            \n            default:\n              return cleanContent;\n          }\n        });\n      });\n      \n      return result;\n    };\n    \n    processedContent = applyActivityStyling(processedContent);\n    console.log(`After processing section \"${section.title}\", sectionHasCode is: ${sectionHasCode}`);\n    \n    // OPTIMIZATION: Only load Prism.js if either global flag is true OR this section has code\n    const shouldLoadPrism = sectionHasCode; // Only load Prism.js if THIS section has code\n    const htmlContent = htmlTemplate(section.title, processedContent, shouldLoadPrism);\n    \n    const fileName = section.fileName;\n    const filePathInFolder = `${folderName}/${fileName}`;\n    \n    const fileData = {\n      fileName: fileName,\n      filePathInFolder: filePathInFolder,\n      htmlContent: htmlContent,\n      section: section,\n      type: section.type,\n      order: i + 1,\n      downloadUrl: `data:text/html;charset=utf-8;base64,${Buffer.from(htmlContent, 'utf8').toString('base64')}`\n    };\n    \n    generatedFiles.push(fileData);\n  }\n\n  // Generate request tables file\n  let requestTablesFile = null;\n\n  if (Array.isArray(extractedRequestSections) && extractedRequestSections.length > 0) {\n    let requestTablesContent = '';\n    \n    extractedRequestSections.forEach((requestSection, index) => {\n      requestTablesContent += `<h2>${requestSection.sectionIdentifier}</h2>\\n`;\n      requestTablesContent += `<p><strong>Section:</strong> ${requestSection.sectionTitle}</p>\\n`;\n      requestTablesContent += `<p><strong>LO:</strong> ${requestSection.sectionLO}, <strong>LS:</strong> ${requestSection.sectionLS}, <strong>LA:</strong> ${requestSection.sectionLA}</p>\\n`;\n      requestTablesContent += `<p><strong>Media Type:</strong> ${requestSection.mediaType}</p>\\n`;\n      requestTablesContent += `<p><strong>Source:</strong> [[style:request]] block</p>\\n`;\n      requestTablesContent += requestSection.requestContent + '\\n\\n';\n    });\n    \n    const requestTablesTitle = `LO${metadata.learningOutcome} - Media/Graphics/Interactive Requests`;\n    const requestTablesHtml = htmlTemplate(requestTablesTitle, requestTablesContent, false); // No Prism.js for request tables\n    const requestTablesFileName = `LO${metadata.learningOutcome}_media_graphics_interactive_requests.html`;\n    const requestTablesFilePathInFolder = `${folderName}/${requestTablesFileName}`;\n    \n    requestTablesFile = {\n      fileName: requestTablesFileName,\n      filePathInFolder: requestTablesFilePathInFolder,\n      htmlContent: requestTablesHtml,\n      type: 'request-tables',\n      order: 0,\n      downloadUrl: `data:text/html;charset=utf-8;base64,${Buffer.from(requestTablesHtml, 'utf8').toString('base64')}`\n    };\n  }\n\n  const folderInstructions = [\n    `Create a folder named: ${folderName}`,\n    `Save the ${generatedFiles.length} HTML files to this folder`,\n    `Files will be organized in the current directory`,\n    `Each file represents one H1 section from the original document`,\n    `Activity styling is applied to [[style:type]] blocks`,\n    `OPTIMIZED: Prism.js and code styles are only loaded when [[style:code]] is detected in input HTML`,\n    `UPDATED: Line numbers now have +2px margin-top for better alignment`,\n    `Request sections marked with [[style:request]] are extracted to separate request tables file`,\n    `Placeholders inserted where media requests were removed`\n  ];\n\n  const finalResult = {\n    success: true,\n    folderPath: folderPath,\n    folderName: folderName,\n    totalFiles: generatedFiles.length + (requestTablesFile ? 1 : 0),\n    generatedFiles: generatedFiles,\n    requestTablesFile: requestTablesFile,\n    folderInstructions: folderInstructions,\n    fileTypes: {\n      'learning-outcome': generatedFiles.filter(f => f.type === 'learning-outcome').length,\n      'learning-step': generatedFiles.filter(f => f.type === 'learning-step').length,\n      'learning-activity': generatedFiles.filter(f => f.type === 'learning-activity').length,\n      'content': generatedFiles.filter(f => f.type === 'content').length,\n      'request-tables': requestTablesFile ? 1 : 0\n    },\n    fileList: [\n      ...(requestTablesFile ? [{\n        fileName: requestTablesFile.fileName,\n        filePathInFolder: requestTablesFile.filePathInFolder,\n        type: requestTablesFile.type,\n        order: requestTablesFile.order\n      }] : []),\n      ...generatedFiles.map(file => ({\n        fileName: file.fileName,\n        filePathInFolder: file.filePathInFolder,\n        type: file.type,\n        order: file.order\n      }))\n    ],\n    debugInfo: data.debugInfo,\n    extractedRequestSections: extractedRequestSections,\n    metadata: metadata,\n    codeHighlighting: {\n      enabled: true, // Per-section loading\n      library: 'Prism.js',\n      conditionalLoading: true,\n      loadedOnlyWhenNeeded: 'YES - Prism.js and code styles only loaded when [[style:code]] is detected',\n      features: ['Auto language detection', 'Line numbers', 'Syntax highlighting', 'Auto-indentation', 'Copy button', '+2px margin-top', 'Conditional loading'],\n      supportedLanguages: ['JavaScript', 'Python', 'PHP', 'C++', 'Java', 'SQL', 'HTML', 'CSS', 'Bash', 'Go', 'Rust', 'C#', 'Plain text'],\n      autoIndentation: {\n        enabled: true,\n        indentSize: 2,\n        languageSpecific: true,\n        features: ['Common indentation removal', 'Language-specific rules', 'Brace matching', 'Tag matching', 'Accurate line counting']\n      },\n      copyButton: {\n        enabled: true,\n        features: ['One-click copy', 'Modern clipboard API', 'Fallback for older browsers', 'Visual feedback', 'Auto-reset after 2 seconds'],\n        compatibility: 'Works in all modern browsers and has fallback for older browsers'\n      },\n      lineNumbering: {\n        enabled: true,\n        features: ['UPDATED: +2px margin-top', 'Same font/spacing as code', 'Last line numbered', 'Narrower & centered code blocks'],\n        marginTop: '+2px (updated from +1px)',\n        fixes: 'All optimizations applied with conditional loading'\n      }\n    }\n  };\n\n  console.log('=== GENERATE HTML FILES DEBUG END ===');\n  console.log('Generated files:', generatedFiles.length);\n  console.log('Request tables file:', requestTablesFile ? 'Yes' : 'No');\n  console.log('Code blocks detected:', containsCodeBlocks ? 'Yes - Prism.js conditionally loaded' : 'No - Prism.js NOT loaded');\n  console.log('Total code blocks with +2px margin-top:', globalCodeCounter);\n  console.log('Conditional loading optimization:', containsCodeBlocks ? 'ACTIVE - Prism.js loaded' : 'ACTIVE - Prism.js NOT loaded');\n  \n  return finalResult;\n\n} catch (error) {\n  console.log('ERROR in Generate HTML Files:', error.message);\n  return {\n    success: false,\n    error: true,\n    message: `HTML generation failed: ${error.message}`,\n    files: [],\n    totalFiles: 0,\n    errorDetails: {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "4",
      "name": "Generate HTML Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Final response with conditional Prism.js loading optimization and +2px margin-top\nconst data = $input.first().json;\n\n// Check if we received an error from previous nodes\nif (data.error || data.validation?.status === 'error') {\n  console.log('ERROR detected in final response:', data.validation?.message || data.errorInfo?.message);\n  \n  // Return error response in expected format for HTML uploader\n  return {\n    success: false,\n    error: true,\n    message: `Processing failed: ${data.validation?.message || data.errorInfo?.message || 'Unknown error'}`,\n    folderPath: null,\n    folderName: 'error',\n    totalFiles: 0,\n    files: [], // Empty files array so HTML uploader doesn't show \"Unexpected Response Format\"\n    fileTypes: {\n      'learning-outcome': 0,\n      'learning-step': 0,\n      'learning-activity': 0,\n      'content': 0,\n      'request-tables': 0\n    },\n    folderInstructions: [\n      'Processing failed due to validation error',\n      'Check the debug information below for details',\n      'Fix the issues and try uploading again'\n    ],\n    fileList: [],\n    requestTablesFile: null,\n    extractedRequestSections: [],\n    debugInfo: [],\n    processingDate: new Date().toISOString(),\n    \n    // Include error information for debug display\n    validation: data.validation,\n    errorInfo: data.errorInfo,\n    \n    ERROR_INFO: {\n      message: 'VALIDATION ERROR OCCURRED',\n      errorType: data.errorInfo?.errorType || 'Unknown',\n      node: data.errorInfo?.node || 'Unknown',\n      timestamp: data.errorInfo?.timestamp || new Date().toISOString(),\n      troubleshooting: data.errorInfo?.troubleshooting || [\n        'Check the debug information above',\n        'Verify your HTML document format',\n        'Ensure all required fields are provided'\n      ]\n    }\n  };\n}\n\n// Normal processing - no errors detected\nconst allFiles = [];\n\nif (data.requestTablesFile) {\n  allFiles.push({\n    fileName: data.requestTablesFile.fileName,\n    filePathInFolder: data.requestTablesFile.filePathInFolder,\n    type: data.requestTablesFile.type,\n    order: data.requestTablesFile.order,\n    downloadUrl: data.requestTablesFile.downloadUrl\n  });\n}\n\nif (data.generatedFiles && Array.isArray(data.generatedFiles)) {\n  data.generatedFiles.forEach(file => {\n    allFiles.push({\n      fileName: file.fileName,\n      filePathInFolder: file.filePathInFolder,\n      type: file.type,\n      order: file.order,\n      downloadUrl: file.downloadUrl\n    });\n  });\n}\n\nconst result = {\n  success: data.success || true,\n  message: `Successfully generated ${data.totalFiles || allFiles.length} HTML files with CONDITIONAL Prism.js loading and +2px margin-top optimization`,\n  folderPath: data.folderPath,\n  folderName: data.folderName,\n  totalFiles: data.totalFiles || allFiles.length,\n  fileTypes: data.fileTypes || {\n    'learning-outcome': allFiles.filter(f => f.type === 'learning-outcome').length,\n    'learning-step': allFiles.filter(f => f.type === 'learning-step').length,\n    'learning-activity': allFiles.filter(f => f.type === 'learning-activity').length,\n    'content': allFiles.filter(f => f.type === 'content').length,\n    'request-tables': allFiles.filter(f => f.type === 'request-tables').length\n  },\n  folderInstructions: data.folderInstructions || [\n    `Create a folder for your HTML files`,\n    `Save the ${allFiles.length} HTML files to this folder`,\n    `Each file represents one section from the original document`,\n    `OPTIMIZED: Prism.js only loads when [[style:code]] is detected in input HTML`,\n    `UPDATED: Code blocks now have +2px margin-top for improved alignment`\n  ],\n  fileList: data.fileList || allFiles.map(file => ({\n    fileName: file.fileName,\n    filePathInFolder: file.filePathInFolder,\n    type: file.type,\n    order: file.order\n  })),\n  files: allFiles,\n  requestTablesFile: data.requestTablesFile,\n  extractedRequestSections: data.extractedRequestSections || [],\n  debugInfo: data.debugInfo || [],\n  processingDate: new Date().toISOString(),\n  \n  // Include validation info for debug display\n  validation: data.validation,\n  \n  // Include code highlighting info with conditional loading and +2px margin-top\n  codeHighlighting: data.codeHighlighting || { enabled: false },\n  \n  UNIVERSAL_TITLE_TRANSFORMATION_INFO: {\n    message: 'UNIVERSAL TITLE TRANSFORMATION ACTIVE',\n    rules: {\n      'X.0.0': 'X. + rest of title (or just X. if no text)',\n      'X.Y.0': 'Step Y: + rest of title (or just Step Y: if no text)',\n      'X.Y.Z': 'Y.Z + rest of title (or just Y.Z if no text)'\n    },\n    examples: [\n      '1.0.0 Learning Outcome Introduction → 1. Learning Outcome Introduction',\n      '3.2.0 → Step 2:',\n      '3.2.0 Overview → Step 2: Overview',\n      '3.2.1 Instruction: → 2.1 Instruction:',\n      '1.2.3 The Importance of Digital Literacy → 2.3 The Importance of Digital Literacy'\n    ],\n    workflowVersion: 'cmp-document-converter-optimized.json',\n    timestamp: new Date().toISOString()\n  },\n  \n  VALIDATION_INFO: {\n    message: 'ENHANCED VALIDATION ACTIVE',\n    features: [\n      'Input structure validation',\n      'HTML content size and format validation',\n      'Filename format and character validation',\n      'Learning outcome range validation',\n      'Section count limits (max 100)',\n      'Request section limits (max 50)',\n      'Content size limits (5MB per section)',\n      'Comprehensive error reporting'\n    ],\n    limits: {\n      maxHtmlContentSize: '10MB',\n      maxSections: 100,\n      maxRequestSections: 50,\n      maxSectionContentSize: '5MB',\n      maxTitleLength: 200,\n      learningOutcomeRange: '1-99'\n    },\n    timestamp: new Date().toISOString()\n  },\n  \n  CODE_HIGHLIGHTING_INFO: {\n    message: data.codeHighlighting?.enabled ? 'CODE SYNTAX HIGHLIGHTING + CONDITIONAL LOADING + +2px MARGIN-TOP ACTIVE' : 'NO CODE BLOCKS DETECTED - PRISM.JS NOT LOADED',\n    library: data.codeHighlighting?.library || 'Prism.js (not loaded)',\n    conditionalLoading: data.codeHighlighting?.conditionalLoading || false,\n    loadedOnlyWhenNeeded: data.codeHighlighting?.loadedOnlyWhenNeeded || 'NO - No code blocks detected',\n    features: data.codeHighlighting?.features || [],\n    supportedLanguages: data.codeHighlighting?.supportedLanguages || [],\n    autoIndentation: data.codeHighlighting?.autoIndentation || { enabled: false },\n    copyButton: data.codeHighlighting?.copyButton || { enabled: false },\n    lineNumbering: data.codeHighlighting?.lineNumbering || { enabled: false },\n    usage: 'Use [[style:code]]...[[/style]] to create syntax-highlighted code blocks with conditional Prism.js loading',\n    autoDetection: 'Language is automatically detected based on code patterns',\n    indentationFeatures: data.codeHighlighting?.autoIndentation?.features || [],\n    copyFeatures: data.codeHighlighting?.copyButton?.features || [],\n    lineNumberingFeatures: data.codeHighlighting?.lineNumbering?.features || [],\n    marginTop: data.codeHighlighting?.lineNumbering?.marginTop || 'N/A',\n    fixes: data.codeHighlighting?.lineNumbering?.fixes || 'No optimizations applied',\n    compatibility: data.codeHighlighting?.copyButton?.compatibility || 'Modern browsers with fallback support',\n    OPTIMIZATION_FEATURES: {\n      conditionalLoading: 'Prism.js and code styles only loaded when [[style:code]] is detected in input HTML',\n      marginTopUpdate: '+2px margin-top for line numbers (updated from +1px)',\n      performanceGain: 'Faster page loads when no code blocks are present',\n      smartDetection: 'Input HTML is scanned for [[style:code]], [[style: code]], and P-wrapped patterns'\n    },\n    timestamp: new Date().toISOString()\n  }\n};\n\nreturn result;"
      },
      "id": "5",
      "name": "Final Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        300
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Process Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Upload": {
      "main": [
        [
          {
            "node": "Parse Document Sections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Document Sections": {
      "main": [
        [
          {
            "node": "Generate HTML Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate HTML Files": {
      "main": [
        [
          {
            "node": "Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-07-23T00:00:00.000Z",
      "updatedAt": "2025-07-23T00:00:00.000Z",
      "id": "1",
      "name": "conditional-prism-2px"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-07-23T00:00:00.000Z",
  "versionId": "1"
}